<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ReteUtilities.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ReteUtilities.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
   @module ReteUtilities
   @requires underscore
*/
var _ = require('underscore');
"use strict";

/**
   Reconnects a joinnode with its alpha memory, once the beta memory is populated
   @param node
   @function relinkToAlphaMemory
*/
var relinkToAlphaMemory = function(node){
    //reconnect an unlinked join node to its alpha memory when there are
    //wmes in said alpha memory
    if(node.isJoinNode === undefined &amp;&amp; node.isNegativeNode === undefined){
        throw new Error("trying to relink alpha on something other than a join node or negative node");
    }
    var ancestor = node.nearestAncestor,
        indices = node.alphaMemory.children.map(d=>d.id);

    //While the ancestor is a child of the alpha memory
    while(ancestor &amp;&amp; indices.indexOf(ancestor.id) === -1){
        //go up an ancestor if it is unlinked to
        ancestor = findNearestAncestorWithAlphaMemory(ancestor,node.alphaMemory.id);
    }
    
    //When finished, if the ancestor exists:
    if(ancestor !== null){
        var index = node.alphaMemory.children.map(d=>d.id).indexOf(ancestor.id);
        //add the node into the child list in front of the ancestor
        node.alphaMemory.children.splice(index,0,node);
    }else{
        //otherwise just add at the end
        node.alphaMemory.children.push(node);
    }

    //remove from the unlinkedChildren Field
    var nodeIndex = node.alphaMemory.unlinkedChildren.map(d=>d.id).indexOf(node.id);
    node.alphaMemory.unlinkedChildren.splice(nodeIndex,1);
        
};

/**
   Reconnects a join node to its beta memory, once the alpha memory is populated
   @param node
   @function relinkToBetaMemory
*/
var relinkToBetaMemory = function(node){
    //relink an unlinked join node to its betamemory when there are tokens
    //in said memory
    //remove from the unlinked children list
    //and add it into the children
    var index = node.parent.unlinkedChildren.map(d=>d.id).indexOf(node.id);
    if(index > -1){
        node.parent.unlinkedChildren.splice(index,1);
        node.parent.children.unshift(node);
    }
};


/**
   If an alpha memory becomes empty, displace all its children temporarily
   @param alphaMemory
   @function unlinkAlphaMemory
*/
var unlinkAlphaMemory = function(alphaMemory){
    //if the alphaMem has no items: UNLINK
    if(alphaMemory.items.length === 0){
        alphaMemory.children.forEach(function(amChild){
            if(amChild.isJoinNode){
                var index = amChild.parent.children.map(d=>d.id).indexOf(amChild.id);
                //splice out
                var removed = amChild.parent.children.splice(index,1);
                //and store
                amChild.parent.unlinkedChildren.push(removed[0]);
            }
        });
    }
};


/**
   If a beta memory becomes empty, displace all its children temporarily
   @param node
   @function ifEmptyBetaMemoryUnlink
*/
var ifEmptyBetaMemoryUnlink = function(node){
    //Now Essentially switch on: BetaMemory, NegativeNode,
    //NCCNode, and NCCPartnerNode

    //BETAMEMORY
    if(node &amp;&amp; node.isBetaMemory){
        //and that betaMemory has no other items
        if(node.items.length === 0){
            //for all the node's children
            node.children.forEach(function(jn){
                if(jn.isJoinNode === undefined){return;}
                var index = jn.alphaMemory.children.map(d=>d.id).indexOf(jn.id);
                if(index !== -1){
                    var removed = jn.alphaMemory.children.splice(index,1);
                    //push it in the unlinked children list
                    jn.alphaMemory.unlinkedChildren.push(removed[0]);
                }
            });
        }
        return true;
    }else{
        return false;
    }        
};

/**
   If a negative node becomes empty, displace its alpha memory's children
   @param node
   @function ifEmptyNegNodeUnlink
*/
var ifEmptyNegNodeUnlink = function(node){
    if(node &amp;&amp; node.isNegativeNode){
        //with elements
        if(node.items.length === 0){
            //unlink alpha memory
            var index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
            var removed = node.alphaMemory.children.splice(index,1);
            node.alphaMemory.unlinkedChildren.push(removed[0]);
        }
    }
};

/**
   Compare an existing constant test node to a constant test that wants to be built
   @param node
   @param constantTestSpec
   @function compareConstantNodeToTest
*/
//taking an alpha node and a ConstantTest
var compareConstantNodeToTest = function(node,constantTestSpec){
    if(node.testField !== constantTestSpec.field
       || node.testValue !== constantTestSpec.value){
        return false;
    }
    if(node.operator !== constantTestSpec.operator){
        return false;
    }
    return true;
};

/**
   Compare specified join tests, to see if a join node is the same as one needed
   @param firstTestSet
   @param secondTestSet
   @function compareJoinTests
*/
var CompareJoinTests = function(firstTestSet,secondTestSet){
    try{
        //compare lengths
        if(firstTestSet.length !== secondTestSet.length) { throw "unequal lengths"; }
        for(var i = 0; i &lt; firstTestSet.length; i++){
            var fTest = firstTestSet[i],
                sTest = secondTestSet[i];
            //compare the bound names
            if(fTest[0] !== sTest[0]) { throw "different bound names"; }
            
            //compare the source names
            if(fTest[1][0] !== sTest[1][0]) { throw "different source names"; }
            
            //compare the bind tests
            if(fTest[1][1].length !== sTest[1][1].length) { throw "different binding tests length"; }
            for(var j = 0; fTest[1][1].length; j++){
                if(fTest[1][1][j][0] !== sTest[1][1][j][0]) { throw "different comp operator"; }
                if(fTest[1][1][j][1] !== sTest[1][1][j][1]) { throw "different comp value"; }
            }
        }
    }catch(e){
        return false;
    }
    return true;
};

/**
   To go up the network, to find appropriate beta network elements linked to the alphamemory
   @param node
   @param alphaMemory
   @function findNearestAncestorWithAlphaMemory
*/
var findNearestAncestorWithAlphaMemory = function(node,alphaMemory){
    //recursive

    //base conditions:
    if(node.dummy){ return null;}
    if(node.isJoinNode || node.isNegativeNode){
        if(node.alphaMemory.id === alphaMemory.id){
            return node;
        }
    }
    //switch recursion into the partner clause
    if(node.isAnNCCNode){
        return findNearestAncestorWithAlphaMemory(node.partner.parent,alphaMemory);
    }
    //recurse:
    return findNearestAncestorWithAlphaMemory(node.parent,alphaMemory);        
};

//--------------------
/**
   Retrieves a value from an object based on a dot style stringstring
   @param wme
   @param dotString
   @function
 */
var retrieveWMEValueFromDotString = function(wme,dotString){
    //get from the node stored in wme.data the value
    //that the dotString address specifies
    var address = dotString.split("."),
        currLocation = wme.data;
    while(address.length > 0){
        var curr = address.shift();
        if(currLocation[curr] !== undefined){
            currLocation = currLocation[curr];
        }
    }

    //return the final location arrived at
    return currLocation;
};

/**
   Remove proposed actions from the retenet, and from their owning tokens
   @param invalidatedActions
   @function
*/

var cleanupInvalidatedActions = function(invalidatedActions){
    if(invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined){
        return;
    }
    var reteNet = invalidatedActions[0].reteNet,
        proposedActions = reteNet.proposedActions,
        idList = invalidatedActions.map(d=>d.id);
    //console.log("Cleaning up:",[idList,invalidatedActions,proposedActions]);
    //filter out the ids from the proposedActions list
    //also removing them from the owning tokens
    proposedActions = _.reject(proposedActions,function(d){
        if(d === undefined) { return true; }
        return idList.indexOf(d.id) !== -1;
    });
    reteNet.proposedActions = proposedActions;
};


/**
   Take a single object that describes a more complex object, and convert it to that more complex object
   @param objDesc
   @param baseObject
   @function objDescToObject
*/
var objDescToObject = function(objDesc,baseObject){
    /* can work on arbitrary depths, will overwrite primitives if later an object is needed
       
       ie: {"values.a" : 5, "values.b" : 10,
       "tags.type" : "rule", "tags.character" : "bob"}
       --->
       {"values": {"a": 5, "b": 10},
       "tags" : {"type" : "rule", "character": "bob"}}
    */
    var newObj = baseObject || {},
        //take the starting object and for all keys
        finalObj = _.keys(objDesc).reduce(function(m,v){
            //split the keys apart
            var keys = v.split(/\./),
                currObj = m,
                currKey;
            //add an object for each key
            while(keys.length > 1){
                currKey = keys.shift();
                if(currObj[currKey] === undefined
                   || typeof currObj[currKey] !== 'object'){
                    currObj[currKey] = {};
                }
                currObj = currObj[currKey];
            }
            currKey = keys.shift();
            currObj[currKey] = objDesc[v];
            return m;
        },newObj);
    return finalObj;
};



//------------------------------
var moduleInterface = {
    "unlinkAlphaMemory" : unlinkAlphaMemory,
    "relinkToAlphaMemory" : relinkToAlphaMemory,
    "ifEmptyBetaMemoryUnlink" : ifEmptyBetaMemoryUnlink,
    "ifEmptyNegNodeUnlink" : ifEmptyNegNodeUnlink,
    "relinkToBetaMemory" : relinkToBetaMemory,
    "compareJoinTests" : CompareJoinTests,
    "compareConstantNodeToTest" : compareConstantNodeToTest,
    "findNearestAncestorWithAlphaMemory" : findNearestAncestorWithAlphaMemory,
    "retrieveWMEValueFromDotString" : retrieveWMEValueFromDotString,
    "cleanupInvalidatedActions" : cleanupInvalidatedActions,
    "objDescToObject" : objDescToObject
};
module.exports = moduleInterface;    

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ReteActionAssert.html">ReteActionAssert</a></li><li><a href="module-ReteActionInterface.html">ReteActionInterface</a></li><li><a href="module-ReteActionRetract.html">ReteActionRetract</a></li><li><a href="module-ReteActions.html">ReteActions</a></li><li><a href="module-ReteActivationAndDeletion.html">ReteActivationAndDeletion</a></li><li><a href="module-ReteArithmeticActions.html">ReteArithmeticActions</a></li><li><a href="module-ReteClassInterface.html">ReteClassInterface</a></li><li><a href="module-ReteComparisonOperators.html">ReteComparisonOperators</a></li><li><a href="module-ReteDataStructures.html">ReteDataStructures</a></li><li><a href="module-ReteNetworkBuilding.html">ReteNetworkBuilding</a></li><li><a href="module-ReteTestExecution.html">ReteTestExecution</a></li><li><a href="module-ReteUtilities.html">ReteUtilities</a></li><li><a href="module-RuleCtors.html">RuleCtors</a></li></ul><h3>Classes</h3><ul><li><a href="module-ReteActionAssert-AssertAction.html">AssertAction</a></li><li><a href="module-ReteActionRetract-RetractAction.html">RetractAction</a></li><li><a href="module-ReteClassInterface-ReteNet.html">ReteNet</a></li><li><a href="module-ReteDataStructures-ActionNode.html">ActionNode</a></li><li><a href="module-ReteDataStructures-AlphaMemory.html">AlphaMemory</a></li><li><a href="module-ReteDataStructures-AlphaMemoryItem.html">AlphaMemoryItem</a></li><li><a href="module-ReteDataStructures-AlphaNode.html">AlphaNode</a></li><li><a href="module-ReteDataStructures-BetaMemory.html">BetaMemory</a></li><li><a href="module-ReteDataStructures-JoinNode.html">JoinNode</a></li><li><a href="module-ReteDataStructures-NCCNode.html">NCCNode</a></li><li><a href="module-ReteDataStructures-NCCPartnerNode.html">NCCPartnerNode</a></li><li><a href="module-ReteDataStructures-NegativeJoinResult.html">NegativeJoinResult</a></li><li><a href="module-ReteDataStructures-NegativeNode.html">NegativeNode</a></li><li><a href="module-ReteDataStructures-ProposedAction.html">ProposedAction</a></li><li><a href="module-ReteDataStructures-ReteNode.html">ReteNode</a></li><li><a href="module-ReteDataStructures-Token.html">Token</a></li><li><a href="module-ReteDataStructures-WME.html">WME</a></li><li><a href="module-RuleCtors-Action.html">Action</a></li><li><a href="module-RuleCtors-Condition.html">Condition</a></li><li><a href="module-RuleCtors-Rule.html">Rule</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-ReteActionInterface-ActionInterface.html">ActionInterface</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Feb 29 2016 20:13:41 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
