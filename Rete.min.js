// wrap-start.frag.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['underscore'], factory);
    } else if (typeof exports === 'object') {
        var _ = require('underscore');
        module.exports = factory(_);
    } else {
        // change "myLib" to whatever your library is called
        root.Rete = factory(root._);
    }
}(this, function (_) {

    
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

define('ReteDataStructures',['require','exports','module','underscore'],function (require, exports, module) {/**
   @file ReteDataStructures
   @purpose to define the data structures required for rete
*/
var _ = require('underscore');
    //PossibleActions = require('./ReteActions');


var nextId = 0;

/**
   @data ReteNet
   @purpose A Data structure to hold what you need to start a retenet.
*/
var ReteNet = function(){
    this.dummyBetaMemory = new BetaMemory();
    this.rootAlpha = new AlphaNode();
    
    //Actions indexed by rule node id:
    this.actions = [];
    //WMEs indexed by id:
    this.allWMEs = [];

    //Actions whose conditions are satisfied, indexed by id
    this.potentialActions = [];
    //Actions that were chosen to be performed
    this.enactedActions = [];

    //Storage of internal nodes:
    this.allReteNodes = {};
    this.allReteNodesByType = {
        "constantTests" : {},
        "alphaMemories" : {},
        "betaMemories" : {},
        "joinNodes" : {},
        "negativeNodes" : {},
        "nccNodes" : {},
        "nccPartnerNodes" : {},
        "actionNodes" : {},
    };
    
    //Automatic retraction capabilities:
    this.currentTime = 1;
    //wmes to assert and retract by absolute time:
    this.wmeLifeTimes = {
        assertions: [],
        retractions: [],
    };
};

//Utility method:
ReteNet.prototype.storeNode = function(node){
    this.allReteNodes[node.id] = node;
    var storeTarget = "unknown";
    if(node.isConstantTestNode){
        storeTarget = "constantTests";
    }else if(node.isAlphaMemory){
        storeTarget = "alphaMemories";
    }else if(node.isBetaMemory){
        storeTarget = "betaMemories";
    }else if(node.isJoinNode){
        storeTarget = "joinNodes";
    }else if(node.isActionNode){
        storeTarget = "actionNodes";
    }else if(node.isNegativeNode){
        storeTarget = "negativeNodes";
    }else if(node.isAnNCCNode){
        storeTarget = "nccNodes";
    }else if(node.isAnNCCPartnerNode){
        storeTarget = "nccPartnerNodes";
    }

    if(this.allReteNodesByType[storeTarget] !== undefined){
        this.allReteNodesByType[storeTarget][node.id] = node;
    }else{
        console.log(node);
        throw new Error("unrecognised type attempted to be stored");
    }
};

/**
   @data ProposedAction
   @purpose describes a queued, but not yet performed, action
   @note queue/invalidate time absolute,
   @note assertTime/retractTime relative to when action is enacted
*/
var ProposedAction = function(reteNet,type,payload,token,queueTime,invalidateTime,assertTime,retractTime){
    this.id = nextId++;
    this.reteNet = reteNet;
    this.actionType = type;//ie: "assert","retract","perform"...
    this.payload = payload; //ie" : {a:3,b:4}...
    this.token = token; //Source Token that spawned this action
    this.queueTime = queueTime;//Time the action was queued
    this.invalidateTime = invalidateTime;//Time the action becomes unactionable
    this.assertTime = assertTime; //Time to perform the action
    this.retractTime = retractTime; //Time to remove the

    //todo: possibly include metrics for selection of actions?
    
    //todo: check for circular reference cleanup

    //update Token:
    //todo: update the name of this

    //Store the proposed action in the token
    this.token.proposedActions.push(this);
    
};


/**
   @data WME
   @purpose to store facts in the rete net
*/
var WME = function(data,assertTime,retractTime){
    this.isWME = true;
    this.data = data;
    //The lifetime of the wme. Asserted at time lifeTime[0],
    //retracted at time lifeTime[1]:
    if(assertTime === undefined) { assertTime = 0; }
    if(retractTime === undefined) { retractTime = 0; }
    this.lifeTime = [assertTime,retractTime];
    //Alpha memories the wme is part of
    this.alphaMemoryItems = [];
    //Tokens the wme is part of
    this.tokens = [];
    //Tokens this wme is blocking
    this.negJoinResults = [];
    this.id = nextId;
    nextId++;
};

/**
   @data Token
   @purpose To combine intermediate results in the beta network
*/
//bindings are updated as the token progresses
var Token = function(parentToken,wme,owningNode,bindings){
    this.isToken = true;
    this.parentToken = parentToken; //ie:owner
    this.wme = wme;
    this.owningNode = owningNode;
    this.children = []; //list of nodes
    this.negJoinResults = [];//list of NegativeJoinResults
    this.nccResults = []; //list of Token
    this.proposedActions = [];
    
    if(this.parentToken){
        this.parentToken.children.unshift(this);
    }
    if(this.wme && this.wme.tokens){
        this.wme.tokens.unshift(this);
    }

    //copy over bindings from parent,
    //then copy in new bindings
    this.bindings = {};

    if(this.parentToken && this.parentToken.bindings){
        _.keys(this.parentToken.bindings).forEach(function(d){
            this.bindings[d] = this.parentToken.bindings[d];
        },this);
    }
    _.keys(bindings).forEach(function(d){
        this.bindings[d] = bindings[d];
    },this);

    this.id = nextId;
    nextId++;        
};

//------------------------------

/**
   @data AlphaMemoryItem
   @purpose a Pairing of a wme with an alpha memory it resides in
*/
//Utility storage of wme and its alphaMemory together
//used in alphamemory and WME
var AlphaMemoryItem = function(wme,alphaMem){
    this.wme = wme;
    this.alphaMemory = alphaMem;
    this.id = nextId;
    nextId++;
};


/**
   @data AlphaNode
   @purpose a node to perform constant tests on newly asserted WMEs
*/
//A constant test node
//constantTest = {field:"",value:"",operator:""};
var AlphaNode = function(parent,constantTestSpec){
    this.id = nextId;
    this.isConstantTestNode = true;
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.children = [];
    this.outputMemory = undefined;
    if(constantTestSpec){
        this.testField = constantTestSpec.field;
        this.testValue = constantTestSpec.value;
        this.operator = constantTestSpec.operator;
    }else{
        this.passThrough = true;
    }
    nextId++;
};

/**
   @data AlphaMemory
   @purpose to store wmes that have passed through constant tests
*/
//Alpha Memory node
var AlphaMemory = function(parent){
    this.isAlphaMemory = true;
    this.items = [];
    this.parent = parent;
    //If adding to a node other than a test node,
    if(parent && parent.isConstantTestNode === undefined){
        //add to children
        this.parent.children.unshift(this);
    }else if(this.parent && this.parent.outputMemory === undefined){
        //if an alphanode, set the ouputmemory field
        this.parent.outputMemory = this;
    }else if(this.parent && this.parentOutputMemory !== undefined){
        throw new Error("trying to create an alpha memory for a node that already has one");
    }
    this.children = [];
    this.unlinkedChildren = [];
    this.referenceCount = 0;
    this.isMemoryNode = true;
    this.id = nextId;
    nextId++;
};

/**
   @data ReteNode
   @purpose provides a base definition of a node in the rete network
*/    
//Base node for the beta network
var ReteNode = function(parent){
    this.children = [];
    this.unlinkedChildren = [];
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.id = nextId;
    nextId++;
};

/**
   @data BetaMemory
   @inherits ReteNode
   @purpose A Node to store tokens in the rete network
*/
//Beta Memory Stores tokens
var BetaMemory = function(parent){
    ReteNode.call(this,parent);
    this.isBetaMemory = true;
    this.isMemoryNode = true;
    this.items = [];
    if(parent === undefined){
        this.dummy = true;
        this.items.push(new Token());
        this.items[0].owningNode = this;
    }

};

/**
   @data JoinNode
   @inherits ReteNode
   @purpose To combine tokens and wmes, according to binding tests
*/
//Join Node combines tokens with wmes
//tests are the binding tuples from a condition
var JoinNode = function(parent,alphaMemory,tests){
    ReteNode.call(this,parent);
    this.isJoinNode = true;
    this.alphaMemory = alphaMemory;
    if(tests){
        this.tests = tests;
    }else{
        this.tests = [];
    }
    if(this.alphaMemory && this.alphaMemory.children){
        this.alphaMemory.children.unshift(this);
        this.alphaMemory.referenceCount += 1;
    }
    this.nearestAncestor = null;
};

/**
   @data ActionNode
   @purpose A Node which, when activated, will cause the effects a rule describes
*/
//Container object for a general graphnode action description    
var ActionNode = function(parent,actionDescriptions,ruleName,reteNet){
    ReteNode.call(this,parent);
    this.isActionNode = true;
    this.name = ruleName;
    this.actionDescriptions = actionDescriptions;
    this.boundActions = [];
    // try{
    //     this.boundActions = actionDescriptions.map(function(d){
    //         if(PossibleActions[d.tags.actionType] === undefined){
    //             throw new Error("Unrecognised action type");
    //         }
    //         return _.bind(PossibleActions[d.tags.actionType],d);
    //     });
    // }catch(e){
    //     this.boundActions = [];
    //     throw e;
    // }
    //reference to retenet, to allow storage of results of firing:
    this.reteNet = reteNet;
};


/**
   @data NegativeJoinResult
   @purpose To Store the combination of a token and a wme that blocks it from progressing through the network
*/
//Storage for a token blocked by a wme
//Updates the owner token and wme as part of its construction
var NegativeJoinResult = function(owner,wme){
    this.owner = owner;
    if(this.owner){
        this.owner.negJoinResults.unshift(this);
    }
    this.wme = wme;
    if(this.wme){
        this.wme.negJoinResults.unshift(this);
    }
    this.id = nextId;
    nextId++;
};


/**
   @data NegativeNode
   @purpose A Node that tests for the abscence of particular wmes
*/
//Negative Node:The node that gates token progression
var NegativeNode = function(parent,alphaMemory,tests){
    if(tests.length === 0){
        throw new Error("Negative Node requires a binding");
    }
    ReteNode.call(this,parent);
    this.isNegativeNode = true;
    this.items = [];
    this.alphaMemory = alphaMemory;
    if(this.alphaMemory){
        this.alphaMemory.referenceCount++;
        this.alphaMemory.children.unshift(this);
    }
    this.tests = tests;
    this.nearestAncestor = null;
};

/**
   @data NCCNode
   @purpose The generalisation of the negative node to multiple conditions, forms the leaf of a subnetwork
*/
//NCC : gates token progression based on a subnetwork
//SEE ALSO: NCCCondition
//old: NegatedConjunctiveConditionNode
var NCCNode = function(parent){
    //don't pass parent in
    ReteNode.call(this);
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.push(this);
    }
    this.isAnNCCNode = true;
    this.items = [];
    this.partner = null;
};


/**
   @data NCCPartnerNode
   @purpose to store potential partial matches in the subnetwork for a NCCNode
*/
//The partner of the NCC, connects to the subnetwork
//old NegConjuConPartnerNode
//var NCCPartner
var NCCPartnerNode = function(parent,num){
    ReteNode.call(this,parent);
    this.isAnNCCPartnerNode = true;
    this.nccNode = null;
    this.numberOfConjuncts = num;
    this.newResultBuffer = [];
    this.id = nextId;
};



//--------------------
/**
   @interface ReteDataStructures
*/
var DataStructures = {
    "WME"              : WME,
    "Token"            : Token,
    "AlphaMemory"      : AlphaMemory,
    "AlphaMemoryItem"  : AlphaMemoryItem,
    "AlphaNode"        : AlphaNode,
    "ReteNode"         : ReteNode,
    "BetaMemory"       : BetaMemory,
    "JoinNode"         : JoinNode,
    "NegativeJoinResult":NegativeJoinResult,
    "NegativeNode"     : NegativeNode,
    "NCCNode"          : NCCNode,
    "NCCPartnerNode"   : NCCPartnerNode,
    "ActionNode"       : ActionNode,
    "ReteNet"          : ReteNet,
    "ProposedAction"   : ProposedAction
};

module.exports = DataStructures;


});

define('ReteComparisonOperators',['require','exports','module'],function (require, exports, module) {/**
   @file ReteComparisonOperators
   @purpose To define the possible operators available for constant test nodes
*/

//Define an object of comparisons able to
//be used in constant tests

//See general utils file for converting to string
//TODO: These can be changed to their actual representations, similar to reteArithActions
var ConstantTestOperators = {
    "EQ" : function(a,b){
        return a===b;
    },
    "LT" : function(a,b){
        return a < b;
    },
    "GT" : function(a,b){
        return a > b;
    },
    "LTE" : function(a,b){
        return a <= b;
    },
    "GTE": function(a,b){
        return a >= b;
    },
    "NE" : function(a,b){
        return a !== b;
    }
};

module.exports = ConstantTestOperators;

});

define('ReteUtilities',['require','exports','module','underscore'],function (require, exports, module) {var _ = require('underscore');
    "use strict";

    /**
       @function relinkToAlphaMemory
       @utility
       @purpose reconnects a joinnode with its alpha memory, once the beta memory is populated
     */
    //reconnect an unlinked join node to its alpha memory when there are
    //wmes in said alpha memory
    var relinkToAlphaMemory = function(node){
        if(node.isJoinNode === undefined && node.isNegativeNode === undefined){
            throw new Error("trying to relink alpha on something other than a join node or negative node");
        }
        
        var ancestor = node.nearestAncestor;
        var indices = node.alphaMemory.children.map(function(d){ return d.id; });

        //While the ancestor is a child of the alpha memory
        while(ancestor && indices.indexOf(ancestor.id) === -1){
            //go up an ancestor if it is unlinked to
            ancestor = findNearestAncestorWithAlphaMemory(ancestor,node.alphaMemory.id);
        }
        
        //When finished, if the ancestor exists:
        if(ancestor !== null){
            var index = node.alphaMemory.children.map(function(d){ return d.id; }).indexOf(ancestor.id);
            //add the node into the child list in front of the ancestor
            node.alphaMemory.children.splice(index,0,node);
        }else{
            //otherwise just add at the end
            node.alphaMemory.children.push(node);
        }

        //remove from the unlinkedChildren Field
        var nodeIndex = node.alphaMemory.unlinkedChildren.map(function(d){ return d.id;}).indexOf(node.id);
        node.alphaMemory.unlinkedChildren.splice(nodeIndex,1);
        
        
    };

    /**
       @function relinkToBetaMemory
       @utility
       @purpose reconnects a join node to its beta memory, once the alpha memory is populated
     */
    //relink an unlinked join node to its betamemory when there are tokens
    //in said memory
    var relinkToBetaMemory = function(node){
        //remove from the unlinked children list
        //and add it into the children
        var index = node.parent.unlinkedChildren.map(function(d){return d.id; }).indexOf(node.id);
        if(index > -1){
            node.parent.unlinkedChildren.splice(index,1);
            node.parent.children.unshift(node);
        }
    };


    /**
       @function unlinkAlphaMemory
       @purpose if an alpha memory becomes empty, displace all its children temporarily
     */
    var unlinkAlphaMemory = function(alphaMemory){
        //if the alphaMem has no items: UNLINK
        if(alphaMemory.items.length === 0){
            alphaMemory.children.forEach(function(amChild){
                if(amChild.isJoinNode){
                    var index = amChild.parent.children.map(function(parentChild){return parentChild.id;}).indexOf(amChild.id);
                    //splice out
                    var removed = amChild.parent.children.splice(index,1);
                    //and store
                    amChild.parent.unlinkedChildren.push(removed[0]);
                }
            });
        }
    };

    
    /**
       @function ifEmptyBetaMemoryUnlink
       @purpose if a beta memory becomes empty, displace all its children temporarily
     */
    //Now Essentially switch on: BetaMemory, NegativeNode,
    //NCCNode, and NCCPartnerNode
    var ifEmptyBetaMemoryUnlink = function(node){
        //BETAMEMORY
        if(node && node.isBetaMemory){
            //and that betaMemory has no other items
            if(node.items.length === 0){
                //for all the node's children
                node.children.forEach(function(jn){
                    if(jn.isJoinNode === undefined){return;}
                    var index = jn.alphaMemory.children.map(function(d){return d.id;}).indexOf(jn.id);
                    if(index !== -1){
                        var removed = jn.alphaMemory.children.splice(index,1);
                        //push it in the unlinked children list
                        jn.alphaMemory.unlinkedChildren.push(removed[0]);
                    }
                });
            }
            return true;
        }else{
            return false;
        }        
    };

    /**
       @function ifEmptyNegNodeUnlink
       @purpose if a negative node becomes empty, displace its alpha memory's children
     */
    var ifEmptyNegNodeUnlink = function(node){
        if(node && node.isNegativeNode){
            //with elements
            if(node.items.length === 0){
                //unlink alpha memory
                var index = node.alphaMemory.children.map(function(d){return d.id;}).indexOf(node.id);
                var removed = node.alphaMemory.children.splice(index,1);
                node.alphaMemory.unlinkedChildren.push(removed[0]);
            }
        }
    };

    

    /**
       @function compareConstantNodeToTest
       @purpose compare an existing constant test node to a constant test that wants to be built
     */
    //taking an alpha node and a ConstantTest
    var compareConstantNodeToTest = function(node,constantTestSpec){
        if(node.testField !== constantTestSpec.field
           || node.testValue !== constantTestSpec.value){
            return false;
        }
        if(node.operator !== constantTestSpec.operator){
            return false;
        }
        return true;
    };

    /**
       @function compareJoinTests
       @purpose Compare specified join tests, to see if a join node is the same as one needed
    */
    var compareJoinTests = function(firstTestSet,secondTestSet){
        if(!(secondTestSet instanceof Array)){
            secondTestSet = _.pairs(secondTestSet);
        }
        
        if(firstTestSet.length === 0 && secondTestSet.length === 0){
            return true;
        }
        var i = firstTestSet.length -1;
        var j = secondTestSet.length -1;
        while(i >= 0 && j >= 0){
            var ts1 = firstTestSet[i],
                ts2 = secondTestSet[j];
            //console.log("comparing",i,j,"|||",firstTestSet[i][0],secondTestSet[j][0],"|||",firstTestSet[i][1],secondTestSet[j][1]);
            if(firstTestSet[i][0] === secondTestSet[j][0]){
                if(firstTestSet[i][1] === secondTestSet[j][1]){
                    i--; j--;
                }else{
                    return false;
                }
            }else if(firstTestSet[i][0] > secondTestSet[j][0]){
                i--;
            }else if(firstTestSet[i][0] < secondTestSet[j][0]){
                j--;
            }else{
                return false;
            }
        }
        if(i === j && i === -1){
            return true;
        }
        return false;
    };


    var altCompareJoinTests = function(firstTestSet,secondTestSet){
        try{
            //compare lengths
            if(firstTestSet.length !== secondTestSet.length) { throw "unequal lengths"; }
            for(var i = 0; i < firstTestSet.length; i++){
                var fTest = firstTestSet[i],
                    sTest = secondTestSet[i];
                //compare the bound names
                if(fTest[0] !== sTest[0]) { throw "different bound names"; }
            
                //compare the source names
                if(fTest[1][0] !== sTest[1][0]) { throw "different source names"; }
            
                //compare the bind tests
                if(fTest[1][1].length !== sTest[1][1].length) { throw "different binding tests length"; }
                for(var j = 0; fTest[1][1].length; j++){
                    if(fTest[1][1][j][0] !== sTest[1][1][j][0]) { throw "different comp operator"; }
                    if(fTest[1][1][j][1] !== sTest[1][1][j][1]) { throw "different comp value"; }
                }
            }
        }catch(e){
            return false;
        }
        return true;
    };

    
    /**
       @function findNearestAncestorWithAlphaMemory
       @recursive
       @purpose To go up the network, to find appropriate beta network elements linked to the alphamemory
    */
    var findNearestAncestorWithAlphaMemory = function(node,alphaMemory){
        //base conditions:
        if(node.dummy){ return null;}
        if(node.isJoinNode || node.isNegativeNode){
            if(node.alphaMemory.id === alphaMemory.id){
                return node;
            }
        }
        //switch recursion into the partner clause
        if(node.isAnNCCNode){
            return findNearestAncestorWithAlphaMemory(node.partner.parent,alphaMemory);
        }
        //recurse:
        return findNearestAncestorWithAlphaMemory(node.parent,alphaMemory);        
    };

    //--------------------
    var retrieveWMEValueFromDotString = function(wme,dotString){
        //get from the node stored in wme.data the value
        //that the dotString address specifies
        var address = dotString.split("."),
            currLocation = wme.data;
        while(address.length > 0){
            var curr = address.shift();
            if(currLocation[curr] !== undefined){
                currLocation = currLocation[curr];
            }
        }

        //return the final location arrived at
        return currLocation;
    };

    //remove proposed actions from the retenet, and from their owning tokens
    var cleanupInvalidatedActions = function(invalidatedActions){
        if(invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined){
            return;
        }
        var reteNet = invalidatedActions[0].reteNet,
            potentialActions = reteNet.potentialActions,
            idList = invalidatedActions.map(function(d){
                return d.id;
            });
        //console.log("Cleaning up:",[idList,invalidatedActions,potentialActions]);
        //filter out the ids from the potentialActions list
        //also removing them from the owning tokens
        potentialActions = _.reject(potentialActions,function(d){
            if(d === undefined) { return false; }
            return idList.indexOf(d.id) !== -1;
        }).filter(function(d){ return d === undefined; });
        reteNet.potentialActions = potentialActions;
    };


    /**
       @function objDescToObject
       @purpose Take a single object that describes a more complex object,
       and convert it to that more complex object

       @note can work on arbitrary depths, will overwrite primitives if later an object is needed

       ie: {"values.a" : 5, "values.b" : 10,
       "tags.type" : "rule", "tags.character" : "bob"}
       --->
       {"values": {"a": 5, "b": 10},
       "tags" : {"type" : "rule", "character": "bob"}}

     */
    var objDescToObject = function(objDesc,baseObject){
        var newObj = baseObject || {},
            //take the starting object and for all keys
            finalObj = _.keys(objDesc).reduce(function(m,v){
                //split the keys apart
                var keys = v.split(/\./),
                    currObj = m,
                    currKey;
                //add an object for each key
                while(keys.length > 1){
                    currKey = keys.shift();
                    if(currObj[currKey] === undefined
                      || typeof currObj[currKey] !== 'object'){
                        currObj[currKey] = {};
                    }
                    currObj = currObj[currKey];
                }
                currKey = keys.shift();
                currObj[currKey] = objDesc[v];
                return m;
            },newObj);
        return finalObj;
    };

    
    
    //------------------------------
    var moduleInterface = {
        "unlinkAlphaMemory" : unlinkAlphaMemory,
        "relinkToAlphaMemory" : relinkToAlphaMemory,
        "ifEmptyBetaMemoryUnlink" : ifEmptyBetaMemoryUnlink,
        "ifEmptyNegNodeUnlink" : ifEmptyNegNodeUnlink,
        "relinkToBetaMemory" : relinkToBetaMemory,
        "compareJoinTests" : altCompareJoinTests,
        //"compareJoinTests" : compareJoinTests,
        "compareConstantNodeToTest" : compareConstantNodeToTest,
        "findNearestAncestorWithAlphaMemory" : findNearestAncestorWithAlphaMemory,
        "retrieveWMEValueFromDotString" : retrieveWMEValueFromDotString,
        "cleanupInvalidatedActions" : cleanupInvalidatedActions,
        "objDescToObject" : objDescToObject
    };
module.exports = moduleInterface;    


});

define('ReteTestExecution',['require','exports','module','./ReteDataStructures','underscore','./ReteUtilities','./ReteComparisonOperators'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    ReteComparisonOps = require('./ReteComparisonOperators');


/**
   @function performJoinTests
   @purpose compare a token and wme, using defined bindings from a joinNode
   @return False if no match, dict of all updated bindings otherwise
*/
var performJoinTests = function(joinNode,token,wme){
    var newBindings = {},
        successState = true,
        varRegex = new RegExp(/^\$/);
    //Populate with current bindings from token
    _.keys(token.bindings).forEach(function(key){
        newBindings[key] = token.bindings[key];
    });


    
    try{
        //add new bindings:
        joinNode.tests.forEach(function(test){
            var newValue = null;
            //retrieve the value
            if(test[1] === "#id" || test[1] === '$id'){
                newValue = wme.id;
            }else{
                newValue = ReteUtil.retrieveWMEValueFromDotString(wme,test[1][0]);
            }
            
            //compare the value for each specified binding test
            var bindingComparisons = test[1][1];
            
            //Compare using any defined binding tests
            bindingComparisons.forEach(function(d){
                var comparator = ReteComparisonOps[d[0]],
                    varName = d[1];
                //if it fails, fail the test
                //use the value in the test, minus the $ at the beginning:
                if(!varRegex.test(varName)) { throw new Error("Non-bound var name"); }
                
                if(!comparator(newValue,newBindings[varName.slice(1)])){
                    throw new Error("Test failed");
                }
            });
            
            if(newBindings[test[0]] === undefined){
                newBindings[test[0]] = newValue;
            }
            if(newBindings[test[0]] !== newValue){
                throw new Error("Test failed");
            }
        });
        
        if(successState){
            return newBindings;
        }else{
            throw new Error("Test failed");
        }
    }catch(e){
        return false;
    }
};


var moduleInterface = {
    "performJoinTests" : performJoinTests,
};
module.exports =  moduleInterface;

});

define('ReteArithmeticActions',['require','exports','module','underscore'],function (require, exports, module) {/**
   @file ReteArithmeticActions
   @purpose to define the arithmetic that an action can perform on a value
*/
var _ = require('underscore');

    "use strict";
    var ArithmeticActions = {
        "+" : function(a,b){
            console.log("Adding:",a,b,"Result:",a+b);
            return a + b;
        },
        "-" : function(a,b){
            return a - b;
        },
        "*" : function(a,b){
            return a * b;
        },
        "/" : function(a,b){
            return a / b;
        },
    };

module.exports = ArithmeticActions;
    


});

define('ReteActions',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {/**
   @file ReteActions
   @purpose To define the functions that a triggered action can call
*/
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');


if(ArithmeticActions === undefined){
    throw new Error("Arithmetic Actions missing");
}

//Action node possible actions:
var actions = {};

//each function returns an object of the form:
//{ action: "", payload: {}, (assertionTime,retractionTime)? }
//Rete Interface.incrementTime uses the action to modify the
//state of the retenet, and so must have an implemented condition for each
//function defined here

//NOTE: these will be called after being bound to an action description,
//so 'this' refers to the information stored in an action/the action object itself,
//while the token information will be passed in

//eg: the action asserts a new wme, with an arithmetic action of +2,
//the action has the information (+ 2), the incoming token as the base value to add to.


//not in place, returns a wme to be dealt with elsewhere
//** @action assert
actions.assert = function(token,reteNet){
    //console.log("Asserting with action:",[this,token,reteNet]);
    //create the data object:
    //initialise from the action's 'values' object
    var newWMEData = _.reduce(_.keys(this.values),function(memo,key){
        memo[key] = null;
        var v = this.values[key];
        //if the value starts with # or $, look it up in the token list
        if(v[0] === "#" || v[0] === "$"){
            //cut off the # or $
            memo[key] = token.bindings[v.slice(1)];
        }
        if(memo[key] === undefined || memo[key] === null){
            memo[key] = v;
        }
        return memo;
    },{},this);
    //If there are no 'values', create it:
    if(newWMEData.values === undefined){
        newWMEData.bindings = {};
    }
    
    //Then copy in the bindings:
    var newDataPlusBindings = _.reduce(_.keys(token.bindings),function(memo,key){
        memo.bindings[key] = token.bindings[key];            
        return memo;
    },newWMEData);
    
    //perform arithmetic:
    _.keys(this.arithmeticActions).forEach(function(key){
        var newVal = Number(newDataPlusBindings[key]);
        if(isNaN(newVal)) { throw new Error("Arithmetic value should be convertable to a number"); }
        //look up the function:
        //because the representation form is: a : ["+", 5]
        var action = ArithmeticActions[this.arithmeticActions[key][0]];
        newDataPlusBindings[key] = action(newVal,Number(this.arithmeticActions[key][1]));
    },this);

    //todo: allow for importing of other vars as the replacement values?
    _.keys(this.regexActions).forEach(function(key){
        var pair = this.regexActions[key],
            regex = new RegExp(pair[0],pair[1]),
            replaceValue = pair[2].match(/\$/) ? newDataPlusBindings[pair[2].slice(1)] : pair[2];
        newDataPlusBindings[key] = newDataPlusBindings[key].replace(regex,replaceValue);
    },this);


    
    //Expand out to object structure
    //ie: {values.a:5, tags.type: rule} -> {values:{a:5},tags:{type:rule}}
    var complexFormData = ReteUtil.objDescToObject(newWMEData);
    console.log("new wme data:",complexFormData);        

    //DONT create the wme, just store the data for it
    //To be returned to activateActionNode
    var proposedAction = new RDS.ProposedAction(reteNet,"assert", complexFormData, token,
                                                reteNet.currentTime,
                                                reteNet.currentTime+2,
                                                reteNet.currentTime+1,
                                                0);
    
    return proposedAction;        
};


//In place retraction. ie: current cycle
//** @action retract
actions.retract = function(token,reteNet){
    //get all wmes the token touches:
    var wmes = [];
    var currToken = token;
    while(currToken && currToken.wme !== undefined){
        wmes.push(currToken.wme);
        currToken = currToken.parentToken;
    }

    //get the wme ids to remove:
    var wmeIDs = _.values(token.bindings);

    //filter the wmeList by the wmeIDs:
    var toRetract = _.filter(wmes,function(wme){
        return _.contains(wmeIDs,wme.id);
    });

    //return the list of all retracted wmes:
    var proposedAction = new RDS.ProposedAction(reteNet,"retract", toRetract, token,
                                                reteNet.currentTime,
                                                reteNet.currentTime+2,
                                                reteNet.currentTime+1,
                                                0);
    return proposedAction;
};

//What other actions might i want?
//aggregate
//modify

//propose action...
//note: an actual proposed action will set action.tag.character to the char.id of
//who is to do it


module.exports = actions;


});

define('ReteActivationAndDeletion',['require','exports','module','./ReteDataStructures','./ReteComparisonOperators','./ReteUtilities','./ReteTestExecution','./ReteActions','underscore'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    ConstantTestOperators = require('./ReteComparisonOperators'),
    ReteUtil = require('./ReteUtilities'),
    ReteTestExecution = require('./ReteTestExecution'),
    PossibleActions = require('./ReteActions'),
    _ = require('underscore');




/**
   @function alphaMemoryActivation
   @purpose stores a wme in an alpha memory
   Trigger an alpha memory with a new wme to store
*/
var alphaMemoryActivation = function(alphaMem,wme){
    var newItem = new RDS.AlphaMemoryItem(wme,alphaMem);
    alphaMem.items.unshift(newItem);
    wme.alphaMemoryItems.unshift(newItem);
    //console.log("AlphaMemory activated:",alphaMem,wme);
    alphaMem.children.forEach(function(child){
        rightActivate(child,wme);
    });
};

/**
   @function constantTestNodeActivation
   @purpose tests a wme against the test in the given node
*/
//Trigger a constant test with a new wme
var constantTestNodeActivation = function(alphaNode,wme){
    //test the wme using the constant test in the node
    var testResult = false;
    if(alphaNode.passThrough){
        testResult = true;
    }else{
        var wmeFieldValue = ReteUtil.retrieveWMEValueFromDotString(wme,alphaNode.testField);
        var value = alphaNode.testValue;
        var operator = alphaNode.operator;
        if(ConstantTestOperators[operator]){
            if(operator !== 'EQ' && operator !== 'NE'){
                testResult = ConstantTestOperators[operator](Number(wmeFieldValue),Number(value));
            }else{
                //console.log("testing:",wmeFieldValue,operator,value,alphaNode,wme);
                testResult = ConstantTestOperators[operator](wmeFieldValue,value);
            }
            
        }
    }
    if(testResult){
        //console.log("successful constant test result",testResult,wme,alphaNode);
        alphaNode.children.forEach(function(child){
            alphaNodeActivation(child,wme);
        });
        if(alphaNode.outputMemory){
            alphaNodeActivation(alphaNode.outputMemory,wme);
        }
    }
    //console.log("ConstantTest Result:",alphaNode,wme,testResult);
    return testResult;
};

/**
   @function alphaNodeActivation
   @utility
   @purpose selects whether to store a wme, or test the wme
*/
//Switchable activation function for alpha network stuff
var alphaNodeActivation = function(alphaNode,wme){
    if(alphaNode.isAlphaMemory){
        alphaMemoryActivation(alphaNode,wme);
    }else if(alphaNode.isConstantTestNode){
        return constantTestNodeActivation(alphaNode,wme);
    }else{
        throw new Error("Unrecognised node:",alphaNode);
    }
};

/**
   @function betaMemoryActivation
   @purpose stores a token in the beta memory
*/
//trigger a beta memory to store a new token
//bindings are from the join node, holding results of the NEW binding tests
//old bindings are still in the token, the constructor of Token will combine the two
//sets of bindings
var betaMemoryActivation = function(betaMemory,token){
    var newToken = token;
    betaMemory.items.unshift(newToken);
    betaMemory.children.forEach(function(child){
        leftActivate(child,newToken);
    });
};


/**
   @function joinNodeLeftActivation
   @purpose given a new token, compares it to all wmes in the related alpha memory
*/
//Trigger a join node with a new token
//will pull all wmes needed from the linked alphaMemory
var joinNodeLeftActivation = function(node,token){
    //If necessary, relink or unlink the
    //parent betamemory or alphamemory
    if(node.parent.items && node.parent.items.length === 1){
        ReteUtil.relinkToAlphaMemory(node);
        if(node.alphaMemory.items.length === 0){
            //unlink beta memory if alphamemory is empty
            var index = node.parent.children.map(function(d){return d.id;}).indexOf(node.id);
            var unlinked = node.parent.children.splice(index,1);
            node.parent.unlinkedChildren.push(unlinked[0]);
        }
    }
    //for each wme in the alpha memory,
    //compare using join tests,
    //and pass on successful combinations
    //to beta memory /negative node children
    //to be combined into tokens
    node.alphaMemory.items.forEach(function(item){
        var currWME = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,token,currWME);
        if(joinTestResult !== undefined && joinTestResult !== false){
            node.children.forEach(function(child){
                leftActivate(child,token,currWME,joinTestResult);
            });//end of loop activating all children
        }
    });//end of looping all wmes in alphamemory
};

/**
   @function joinNodeRightActivation
   @purpose given a new wme, compares it against all tokens in the related beta memory
*/
//Trigger a join node with a new wme
//pulling all necessary tokens from the parent as needed
var joinNodeRightActivation = function(node,wme){
    //relink or unlink as necessary
    if(node.alphaMemory.items.length === 1){
        ReteUtil.relinkToBetaMemory(node);
        if(node.parent.items.length === 0){
            var index = node.alphaMemory.children.map(function(d){ return d.id; }).indexOf(node.id);
            var unlinked = node.alphaMemory.children.splice(index,1);
            node.alphaMemory.unlinkedChildren.push(unlinked[0]);
        }
    }

    //For all tokens, compare to the new wme,
    //pass on successful combinations to betamemory/negative node
    node.parent.items.forEach(function(currToken){
        //console.log("--------\nComparing: ",currToken.bindings,"\n To: ",wme.data,"\n using: ",node.tests);
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            node.children.forEach(function(currNode){
                leftActivate(currNode,currToken,wme,joinTestResult);
            });
        }
    });
};


/**
   @function activateActionNode
   @purpose given a new token, activates any stored actions necessary
*/
var activateActionNode = function(actionNode,token){
    //get the actions the node embodies:
    var boundActionFunctions = actionNode.boundActions,
        //get the individual new proposed actions
        newProposedActions = boundActionFunctions.map(function(d){
            return d(token,actionNode.reteNet);
        }),
        newProposedActionIds = newProposedActions.map(function(d){
            return d.id;
        });
    
    //store the proposed actions in the reteNet.potential actions
    //and also tie all the actions that fire together by their ids
    //ie: {action:"assert",payload:wme}
    newProposedActions.forEach(function(d){
        d.parallelActions = newProposedActionIds;
        actionNode.reteNet.potentialActions[d.id] = d;
    });
};


/**
   @function leftActivate
   @utility
   @purpose selects what node to activate as appropriate, for a new token
*/
//Utility leftActivation function to call
//whichever specific type is needed
var leftActivate = function(node,token,wme,joinTestResults){
    //Construct a new token if supplied the correct
    //parameters
    if(joinTestResults && wme){
        token = new RDS.Token(token,wme,node,joinTestResults);
        //owning node is the node going into, rather than coming out of
    }
    //Activate the node:
    //Essentially a switch of:
    //betaMemory, JoinNode, NegativeNode, NCC, PartnerNode,
    //and Action
    if(node.__isDummy){
        //pass on, because this is a test
    }else if(node.isBetaMemory){
        betaMemoryActivation(node,token);
    }else if(node.isJoinNode){
        joinNodeLeftActivation(node,token);
    }else if(node.isNegativeNode){
        negativeNodeLeftActivation(node,token);
    }else if(node.isAnNCCNode){
        nccNodeLeftActivation(node,token);
    }else if(node.isAnNCCPartnerNode){
        nccPartnerNodeLeftActivation(node,token);
    }else if(node.isActionNode){
        activateActionNode(node,token);
    }else{
        throw new Error("Unknown node type leftActivated");
    }
    return token;
};

/**
   @function rightActivate
   @purpose selects what node to activate, given a new wme
*/
var rightActivate = function(node,wme){
    if(node.isJoinNode){
        joinNodeRightActivation(node,wme);
    }else if(node.isNegativeNode){
        negativeNodeRightActivation(node,wme);
    }else{
        throw new Error("Tried to rightActivate Unrecognised node");
    }
};

/**
   @function negativeNodeLeftActivation
*/
//Trigger a negative node from a new token
//brings in bindings, creates a new token as necessary,
//combining bindings to.
var negativeNodeLeftActivation = function(node,newToken){
    //Relink
    if(node.items.length === 0){
        ReteUtil.relinkToAlphaMemory(node);
    }
    node.items.unshift(newToken);

    node.alphaMemory.items.forEach(function(item){
        var currWme = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,newToken,currWme);
        if(joinTestResult){
            //adds itself to the token and
            //wme as necessary to block the token
            var joinResult = new RDS.NegativeJoinResult(newToken,currWme);
        }
    });

    //if no wmes block the token, pass it on down the network
    if(newToken.negJoinResults.length === 0){
        node.children.forEach(function(child){
            leftActivate(child,newToken);
        });
    }
    
};

/**
   @function negativeNodeRightActivation
*/
//trigger a negative node from a new wme,
//getting all tokens stored, comparing to the wme.
//any that the wme blocks, gets an additional negative Join result
//any that don't get blocked should already have been activated
var negativeNodeRightActivation = function(node,wme){
    node.items.forEach(function(currToken){
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            if(currToken.negJoinResults.length === 0){
                //todo: fix this
                var invalidatedActions = deleteDescendentsOfToken(currToken);
                ReteUtil.cleanupInvalidatedActions(invalidatedActions);
            }
            //Adds itself to the currToken and wme as
            //necessary
            var negJoinResult = new RDS.NegativeJoinResult(currToken,wme);
        }
    });
};

/**
   @function nccNodeLeftActivation
*/
//from a new token, trigger the subnetwork?
var nccNodeLeftActivation = function(nccNode,token){
    //Create and store the incoming token from prior join node
    if(nccNode.isAnNCCNode === undefined){
        throw new Error("nccNodeLeftActivation should be on an NCCNode");
    }
    if(token.isToken === undefined){
        throw new Error("nccNodeLeftActivation should be on a token");
    }
    var newToken = token;
    nccNode.items.unshift(newToken);

    //the partner's network MUST fire before the nccnode
    //hence this. all the new results' in the partners new result buffer,
    //are from the same origin as token
    //if there are new results to process:
    while(nccNode.partner && nccNode.partner.newResultBuffer.length > 0){
        var newResult = nccNode.partner.newResultBuffer.pop();
        //add the subnetworks result as a blocking token
        newToken.nccResults.unshift(newResult);
        //set the subnetwork result to have its parent as the new token
        newResult.parentToken = newToken;
    }

    //if the new token has no blocking tokens,
    //continue on
    if(newToken.nccResults.length === 0){
        nccNode.children.forEach(function(child){
            leftActivate(child,newToken);
        });
    }
};

/**
   @function nccPartnerNodeLeftActivation
*/
//the nccPartnerNode is activated by a new token from the subnetwork
//figure out who owns this new token from the main (positive) network
var nccPartnerNodeLeftActivation = function(partner,token){
    //the partner's ncc
    var nccNode = partner.nccNode,
        //the token created in left activate, with partner as owner
        newToken = token,
        ownersToken = token.parentToken,//the prior token
        ownersWme = token.wme,//the prior wme
        owner;

    
    for(var i = 1; i < partner.numberOfConjuncts; i++){
        //go up the owner chain
        ownersToken = ownersToken.parentToken;
        ownersWme = ownersWme.wme;
    }

    //find an owner in the ncc node's memory to link to
    if(nccNode !== undefined){
        var possible_tokens = nccNode.items.map(function(d){
            if(d.parentToken.id === ownersToken.id && d.wme.id === ownersWme.id){
                return d;
            }}).filter(function(d){return d !== undefined;});
        owner = possible_tokens[0];
    }

    //link the owner and the new token
    if(owner !== undefined){
        //the necessary owner exists in the nccNode,
        //so update it:
        owner.nccResults.unshift(newToken);
        newToken.parent = owner;
        var invalidatedActions = deleteDescendentsOfToken(owner);
        ReteUtil.cleanupInvalidatedActions(invalidatedActions); 
    }else{        
        //else no owner: add to temp buffer to wait for the ncc node to be activated
        partner.newResultBuffer.unshift(newToken);
    }
};


/**
   @function activateIfNegatedJRIsUnblocked
*/
var activateIfNegatedJRIsUnblocked = function(nJR){
    var currJoinResult = nJR;
    //if the negation clears, activate it
    if(currJoinResult.owner.negJoinResults.length === 0){
        currJoinResult.owner.owningNode.children.forEach(function(child){
            //activate the token for all its owners children
            leftActivate(child,currJoinResult.owner);
        });
    }
};


//** @deprecated ifNCCPartnerNodeActivateIfAppropriate
//** @note is displaced into methods above to stop circular dependencies with retedeletion
// var ifNCCPartnerNodeActivateIfAppropriate = function(token){
//     if(token && token.owningNode
//        && token.owningNode.isAnNCCPartnerNode){
//         if(token.parentToken.nccResults.length === 0){
//             token.owningNode.nccNode.children.forEach(function(d){
//                 leftActivate(d,token.parentToken);
//             });
//             return true;
//         }
//     }
//     return false;
// };

/**
   @function removeAlphaMemoryItemsForWME
   @purpose to remove a wme from all alpha memories it is stored in
   @postCondition wme.alphaMemoryItems is empty
*/
var removeAlphaMemoryItemsForWME = function(wme){
    //remove alpha memory items
    wme.alphaMemoryItems.forEach(function(item){
        //unlink the alphamemory from the item
        var index = item.alphaMemory.items.map(function(d){return d.id;}).indexOf(item.id);
        if(index !== -1){ item.alphaMemory.items.splice(index,1);}
        //unlink the alphaMemory itself if it is now empty
        //will unlink if am.items.length === 0
        ReteUtil.unlinkAlphaMemory(item.alphaMemory);
        //clear the item's links
        item.alphaMemory = undefined;
        item.wme = undefined;
    });
    //completely clear am items:
    wme.alphaMemoryItems = [];
};

/**
   @function deleteAllTokensForWME
   @purpose to cleanup all tokens a wme is part of
*/
var deleteAllTokensForWME = function(wme){
    var invalidatedActions = [];
    //For all tokens
    while(wme.tokens.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(wme.tokens[0]));
    }

    return invalidatedActions;
    
};

/**
   @function deleteAllNegJoinResultsForWME
   @purpose For negative conditions, discount the wme as a block
*/
var deleteAllNegJoinResultsForWME = function(wme){
    //unlink the negative Join results in the owning token
    wme.negJoinResults.forEach(function(jr){
        var index = jr.owner.negJoinResults.map(function(j){
            return j.id;
        }).indexOf(jr.id);
        if(index !== -1){
            jr.owner.negJoinResults.splice(index,1);
        }
        activateIfNegatedJRIsUnblocked(jr);
        //remove internal references:
        jr.owner = undefined;
        jr.wme = undefined;
    });
    //completely clear negjoinresults
    wme.negJoinResults = [];
};


/**
   @function removeNegJoinResultsForToken
   @purpose to delete any blocked tokens in negative conditions
*/
var removeNegJoinResultsForToken = function(token){
    //remove Negative join results
    token.negJoinResults.forEach(function(jr){
        var index = jr.wme.negJoinResults.map(function(d){return d.id;}).indexOf(jr.id);
        if(index !== -1){
            jr.wme.negJoinResults.splice(index,1);
        }
        //clear the references
        jr.wme = undefined;
        jr.token = undefined;
    });
    token.negJoinResults = [];
};


/**
   @function removeTokenFromNode
   @purpose To remove a token from whatever node created it
*/
//Now the utility functions for deleteing token:
var removeTokenFromNode = function(token){
    //Deal with if the owning node is NOT an NCC
    if(token.owningNode
       && token.owningNode.isAnNCCPartnerNode === undefined
       && token.owningNode.isMemoryNode){
        //by removing the token as an element in that node
        var index = token.owningNode.items.map(function(d){
            return d.id;
        }).indexOf(token.id);
        if(index !== -1){
            token.owningNode.items.splice(index,1);
        }
    }
};

/**
   @function removeTokenFromWME
   @purpose to clean a token up, removing it from any WME references
*/
var removeTokenFromWME = function(token){
    //remove the token from the wme it is based on
    if(token.wme && token.wme.tokens){
        var index = token.wme.tokens.map(function(d){return d.id;}).indexOf(token.id);
        if(index !== -1){
            token.wme.tokens.splice(index,1);
        }
    }
};

/**
   @function removeTokenFromParentToken
   @purpose cleanup the token from its parents list
*/
var removeTokenFromParentToken = function(token){
    //Remove the token from it's parent's child list
    if(token && token.parentToken){
        var index = token.parentToken.children.map(function(d){return d.id;}).indexOf(token.id);
        if(index !== -1){
            token.parentToken.children.splice(index,1);
        }
    }
};




/*
  Removes DOWNWARD links, but leaves UPWARD links intact
  Do a number of things:
  clean up tokens stored in a node
  remove any reference to the node from a connected alpha
  remove any reference to the node from a parent

  +: call recursively on any parent that has no children
*/

/**
   @function deleteNodeAndAnyUnusedAncestors
   @purpose cleanup an unused node and any parent nodes that are also unused once this node is gone.
*/
var deleteNodeAndAnyUnusedAncestors = function(node){
    var index,
        invalidatedActions = [];
    //if NCC, delete partner to
    if(node.isAnNCCNode){
        invalidatedActions = invalidatedActions.concat(deleteNodeAndAnyUnusedAncestors(node.partner));
    }
    
    //clean up tokens
    if(node.isBetaMemory){
        while(node.items.length > 0){
            invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(node.items[0]));
        }
    }
    if(node.isAnNCCPartnerNode){
        while(node.newResultBuffer.length > 0){
            invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(node.items[0]));
        }
    }

    //clean up any associated alphamemory
    if(node.isJoinNode || node.isNegativeNode && node.alphaMemory){
        index = node.alphaMemory.children.map(function(d){ return d.id; }).indexOf(node.id);
        if(index > -1){
            node.alphaMemory.children.splice(index,1);
            node.alphaMemory.referenceCount--;
        }
        if(node.alphaMemory.referenceCount === 0){
            //TODO: write delete alpha memory
            //deleteAlphaMemory(node.alphaMemory);
        }
    }
    
    //remove the node from its parent
    if(node.parent){
        //check the child list:
        index = node.parent.children.map(function(d){
            return d.id;
        }).indexOf(node.id);
        if(index !== -1){                            
            node.parent.children.splice(index,1);
        }else{
            //check the unlinked children list:
            index = node.parent.unlinkedChildren.map(function(d){ return d.id;}).indexOf(node.id);
            if(index !== -1){
                node.parent.unlinkedChildren.splice(index,1);
            }
        }
    }

    //delete parent node if its got no children
    if(node.parent && node.parent.children.length === 0
       && node.parent.unlinkedChildren
       && node.parent.unlinkedChildren.length === 0){
        invalidatedActions = invalidatedActions.concat(deleteNodeAndAnyUnusedAncestors(node.parent));
    }
    //deallocate memory for none

    return invalidatedActions;
    
};


/**
   @function deleteDescendentsOfToken
   @purpose simplification of removing children of a token, but not the token itself
   @utility
*/
//utility function to delete all descendents without deleting the token
var deleteDescendentsOfToken = function(token){
    var invalidatedActions = [];
    while(token.children.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(token.children[0]));
    }
    invalidatedActions = invalidatedActions.concat(token.proposedActions);
    return invalidatedActions;
};


/**
   @function deleteTokenAndDescendents
   @purpose To remove a token and clean it 
   delete a token and all the tokens that rely on it
   a bit of a frankenstein. Deletes the token,
   deletes descendents, but also sets and cleans up 
   left unlinking of join nodes, AND
   activates NCC's that are no longer blocked
*/
var deleteTokenAndDescendents = function(token){
    var invalidatedActions = [];
    
    //Recursive call:
    while(token.children.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(token.children[0]));
    }

    //Base Cases:
    //remove memory items
    removeTokenFromNode(token);
    removeTokenFromWME(token);
    removeTokenFromParentToken(token);
    
    ReteUtil.ifEmptyBetaMemoryUnlink(token.owningNode);
    ReteUtil.ifEmptyNegNodeUnlink(token.owningNode,token.id);

    removeNegJoinResultsForToken(token);

    cleanupNCCResultsInToken(token);
    cleanupNCCPartnerOwnedToken(token);
    
    if(token && token.owningNode
       && token.owningNode.isAnNCCPartnerNode
       && token.parentToken.nccResults.length === 0){
        //Activate newly unblocked Token
        //todo: should this be nccnode AND/OR negNode?
        token.owningNode.nccNode.children.forEach(function(d){
            leftActivate(d,token.parentToken);
        });
    }

    //get the queued actions linked with the token, and return them for cleanup
    invalidatedActions = invalidatedActions.concat(token.proposedActions);
    
    return invalidatedActions;
};

/**
   @function cleanupNCCResultsInToken
*/
var cleanupNCCResultsInToken = function(token){
    //NCCNODE
    if(token && token.owningNode && token.owningNode.isAnNCCNode){
        //for all the nccResult tokens, delete them
        token.nccResults.forEach(function(nccR){
            //remove the nccR token from its linked wme
            if(nccR.wme){
                var index = nccR.wme.tokens.map(function(d){return d.id;}).indexOf(nccR.id);
                if(index !== -1){
                    nccR.wme.tokens.splice(index,1);
                }
            }
            if(nccR.parent){
                //remove the token from it's parent
                var nccRindex = nccR.parent.children.map(function(t){return t.id;}).indexOf(nccR.id);
                if(nccRindex !== -1){
                    nccR.parent.children.splice(nccRindex,1);
                }
            }
        });
        //clear the nccResults
        token.nccResults = [];
        return true;
    }else{
        return false;
    }
};

/**
   @function cleanupNCCPartnerOwnedToken
*/
var cleanupNCCPartnerOwnedToken = function(token){
    //NCCPARTNERNODE
    if(token.owningNode
       && token.owningNode.isAnNCCPartnerNode
       && token.parentToken){
        //remove from owner.nccResults:
        var index = token.parentToken.nccResults.map(function(d){return d.id;}).indexOf(token.id);
        if(index !== -1){
            token.parentToken.nccResults.splice(index,1);
        }
        return true;
    }else{
        return false;
    }
};



var moduleInterface = {
    "deleteDescendentsOfToken" : deleteDescendentsOfToken,
    "removeAlphaMemoryItemsForWME" : removeAlphaMemoryItemsForWME,
    "deleteAllTokensForWME" : deleteAllTokensForWME,
    "deleteAllNegJoinResultsForWME" : deleteAllNegJoinResultsForWME,
    "deleteNodeAndAnyUnusedAncestors" : deleteNodeAndAnyUnusedAncestors,
    "leftActivate" : leftActivate,
    "rightActivate" : rightActivate,
    "alphaNodeActivation" : alphaNodeActivation,
    "activateIfNegatedJRIsUnblocked" : activateIfNegatedJRIsUnblocked,
};
module.exports = moduleInterface;

});

define('ReteNetworkBuilding',['require','exports','module','./ReteDataStructures','./ReteUtilities','./ReteActivationAndDeletion','underscore'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    ReteUtil = require('./ReteUtilities'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    _ = require('underscore');


/**
   @function buildOrShareNetworkForConditions
   @purpose to add all given conditions to the network
*/
var buildOrShareNetworkForConditions = function(parent,conditions,rootAlpha,allNodes,reteNet){
    var currentNode = parent;
    var alphaMemory;
    //for each condition
    conditions.forEach(function(condition){
        if(condition.tags.type !== 'condition' && condition.tags.type !== 'negConjCondition'
           && condition.tags.type !== 'negCondition' && condition.tags.type !== 'rule'){
            throw new Error("Inappropriate condition format");
        }
        //get the binding tests for join nodes
        var tests = _.pairs(condition.bindings);            
        if(condition.tags.isPositive !== undefined){
            currentNode = buildOrShareBetaMemoryNode(currentNode,reteNet);
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareJoinNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.isNegative !== undefined){
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareNegativeNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.isNCCCondition !== undefined){
            currentNode = buildOrShareNCCNodes(currentNode,condition,rootAlpha,allNodes,reteNet);
        }else if(condition.tags.type === 'rule'){
            //for using other rules as composable conditions
            var ruleConditions = _.keys(condition.conditions).map(function(d){
                return this[d];
            },allNodes);                
            currentNode = buildOrShareNetworkForConditions(currentNode,ruleConditions,rootAlpha,allNodes,reteNet);
        }else{
            console.error("Problematic Condition:",condition);
            throw new Error("Unrecognised condition type");
        }
    });
    //return current node
    var finalBetaMemory = buildOrShareBetaMemoryNode(currentNode,reteNet);
    return finalBetaMemory;
};

/**
   @function buildOrShareConstantTestNode
   @purpose Reuse, or create a new, constant test node, for the given test
*/
var buildOrShareConstantTestNode = function(parent,constantTestSpec,reteNet){
    
    //Todo: write this as a functional select/find
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        var node = children[i];
        if(ReteUtil.compareConstantNodeToTest(node,constantTestSpec)){
            return node;
        }
    }
    var newAlphaNode = new RDS.AlphaNode(parent,constantTestSpec);

    reteNet.storeNode(newAlphaNode);

    return newAlphaNode;
};


/**
   @function buildOrShareAlphaMemory
   @purpose Create alpha network as necessary, stick an alpha memory on the end
   @reminder Rule{Conditions[]}, Condition{constantTests:[],bindings:[[]]}
*/
var buildOrShareAlphaMemory = function(condition,root,allNodes,reteNet){
    var currentNode = root,
        constantTests = condition.constantTests;//[{field:,op:,value:}]
    
    currentNode = constantTests.reduce(function(m,v){
        return buildOrShareConstantTestNode(m,v,reteNet);
    },currentNode);
    
    //see if there is an existing memory for this condition.
    //if so, return existing alphamemory
    if(currentNode.outputMemory !== undefined){
        return currentNode.outputMemory;
    }
    //else: create the alpha memory
    //ctor will update the current node's outputMemory field
    var newAlphaMemory = new RDS.AlphaMemory(currentNode);
    //run wmes in working memory against the alpha network
    reteNet.storeNode(newAlphaMemory);
    return newAlphaMemory;
};

/**
   @function buildOrShareBetaMemoryNode
   @purpose given a node (ie: join), stick a betamemory on it as a child
*/
var buildOrShareBetaMemoryNode = function(parent,reteNet){
    //if passed in the dummy top node, return it:
    if(parent.isBetaMemory === true){
        return parent;
    }
    
    //if theres an available beta memory to use,
    //return that
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        var child = children[i];
        if(child.isBetaMemory){
            return child;
        }
    }
    //else: create a new beta memory
    //ctor should update  parent's children
    var newBetaMemory = new RDS.BetaMemory(parent);
    //update it with matches
    updateNewNodeWithMatchesFromAbove(newBetaMemory);

    reteNet.storeNode(newBetaMemory);
    
    //return new beta memory
    return newBetaMemory;
};




/**
   @function buildOrShareJonNode
   @purpose To reuse, or create a new, join node linking an alpha memory and betamemory
*/
var buildOrShareJoinNode = function(parent,alphaMemory,tests,reteNet){
    //convert tests if necessary:
    if(!(tests instanceof Array)){
        tests = _.pairs(tests);
    }
    
    //see if theres a join node to use already
    var allChildren = parent.children.concat(parent.unlinkedChildren);
    for(var i = 0; i < allChildren.length; i++){
        var child = allChildren[i];
        if(child.isJoinNode && child.alphaMemory.id === alphaMemory.id && ReteUtil.compareJoinTests(child.tests,tests)){
            //return it
            return child;
        }
    }
    //else: create a new join node
    //increment alphamemories reference count in the constructor
    var newJoinNode = new RDS.JoinNode(parent,alphaMemory,tests);
    //set the nearest ancestor
    newJoinNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);

    //if either parent memory is empty, unlink
    if(parent.items.length === 0){
        //BETA IS EMPTY: UNLINK RIGHT
        var index = alphaMemory.children.map(function(d){ return d.id; }).indexOf(newJoinNode.id);
        var removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.unshift(removed[0]);
    }else if(alphaMemory.items.length === 0){
        //ALPHA IS EMPTY: UNLINK LEFT
        var newNodeIndex = parent.children.map(function(d){
            return d.id;
        }).indexOf(newJoinNode.id);
        var removedNode = parent.children.splice(newNodeIndex,1);
        parent.unlinkedChildren.unshift(removedNode[0]);
    }
    //return new join node
    reteNet.storeNode(newJoinNode);
    
    return newJoinNode;
};

/**
   @function buildOrShareNegativeNode
   @purpose To reuse, or build a new, negative node
*/
var buildOrShareNegativeNode = function(parent,alphaMemory,tests,reteNet){
    if(!(tests instanceof Array)) { tests = _.pairs(tests); }
    //see if theres an existing negative node to use
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i ++){
        var child = children[i];
        if(child.isNegativeNode
           && child.alphaMemory.id === alphaMemory.id
           && ReteUtil.compareJoinTests(child.tests,tests)){
            return child;
        }
    }
    var newNegativeNode = new RDS.NegativeNode(parent,alphaMemory,tests);
    newNegativeNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);
    //update with matches
    updateNewNodeWithMatchesFromAbove(newNegativeNode);
    //unlink if it has no tokens
    if(newNegativeNode.items.length === 0){
        var index = alphaMemory.children.map(function(d){
            return d.id;
        }).indexOf(newNegativeNode.id);
        var removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.push(removed[0]);
    }
    //return new negative node

    reteNet.storeNode(newNegativeNode);
    return newNegativeNode;
};

/**
   @function buildOrShareNCCNodes
   @purpose construction of NCCConditions
*/
var buildOrShareNCCNodes = function(parent,condition,rootAlpha,allNodes,reteNet){
    if(condition.tags.isNCCCondition === undefined){
        throw new Error("BuildOrShareNCCNodes only takes NCCCondition");
    }
    //build a network for the conditions
    var conditions = _.keys(condition.conditions).map(function(d){
        return this[d];
    },allNodes),
        //build the subnetwork
        bottomOfSubNetwork = buildOrShareNetworkForConditions(parent,conditions,rootAlpha,allNodes,reteNet);
    //find an existing NCCNode with partner to use
    for(var i = 0; i < parent.children.length; i++){
        var child = parent.children[i];
        if(child.isAnNCCNode && child.partner.parent.id === bottomOfSubNetwork.id){
            return child;
        }
    }
    
    //else: build NCC and Partner nodes
    var newNCC = new RDS.NCCNode(parent),
        newNCCPartner = new RDS.NCCPartnerNode(bottomOfSubNetwork,condition.conditions.length);

    newNCC.partner = newNCCPartner;
    newNCCPartner.nccNode = newNCC;
    //update NCC
    updateNewNodeWithMatchesFromAbove(newNCC);
    //update partner
    updateNewNodeWithMatchesFromAbove(newNCCPartner);

    reteNet.storeNode(newNCC);
    reteNet.storeNode(newNCCPartner);
    
    return newNCC;
};


/**
   @function updateNewNodeWithMatchesFromAbove
   @purpose pulls tokens down from parent upon new creation
*/
//essentially a 4 state switch:
//betaMemory, joinNode, negativeNode, NCC
var updateNewNodeWithMatchesFromAbove = function(newNode){
    var i, token;
    var parent = newNode.parent;
    if(parent.isBetaMemory){
        for(i in parent.items){
            ReteActivationsAndDeletion.leftActivate(newNode,parent.items[i]);
        }
    }else if(parent.isJoinNode){
        var savedChildren = parent.children,
            items = _.values(parent.alphaMemory.items);
        parent.children = [newNode];
        for(i = 0; i < items.length; i++){
            var item = items[i];
            ReteActivationsAndDeletion.rightActivate(parent,item.wme);
        }
        parent.children = savedChildren;
    }else if(parent.isNegativeNode){
        var items = _.values(parent.items);
        for(i = 0; i < items.length; i++){
            token = items[i];
            if(token.negJoinResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }else if(parent.isAnNCCNode){
        var items = _.values(parent.items);
        for(i = 0; i < items.length; i++){
            token = parent.items[i];
            if(token.nccResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }
};



var moduleInterface = {
    "buildOrShareNetworkForConditions" : buildOrShareNetworkForConditions,
};
module.exports =  moduleInterface;


});

define('RuleCtors',['require','exports','module'],function (require, exports, module) {//Ctors for Rules

/**
   Rule Ctor. Holds conditions and actions
*/
var nextId = 0;

var Rule = function(name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { type : "rule" };
    this.conditions = {};
    this.actions = {};
};

Rule.prototype.addCondition = function(condition){
    this.conditions[condition.id] = condition;
    return this;
};

Rule.prototype.addAction = function(action){
    this.actions[action.id] = action;
    return this;
};

/**
   Condition Ctor. Holds tests, bindings, and other conditions
 */
var Condition = function(type){
    this.id = nextId++;
    type = type === undefined ? "condition" : type;
    switch(type){
    case "condition":
        this.tags = { type : "condition",
                      isPositive : true };
        break;
    case "negCondition":
        this.tags = { type : "condition",
                      isNegative : true };
        break;
    case "negConjCondition":
        this.tags = { isNCCCondition : true,
                      type : "negConjCondition" };
        break;
    default:
        throw new Error("Unrecognised condition");
    };
    this.constantTests = [];
    this.bindings = {};
    this.conditions = {};    
};

Condition.prototype.addTest = function(field,op,val){
    this.constantTests.push({
        field : field,
        operator : op,
        value : val
    });
    return this;
};

Condition.prototype.addBinding = function(boundName,dataName,tests){
    //tests as pairs of op and value/boundName
    this.bindings[boundName] = [dataName,tests];

};

/**
   Action constructor, defines data/values to put in a new wme,
   arithmetic and regex actions to apply to those values
 */
var Action = function(actionType, name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { actionType : actionType || "assert" };
    this.values = {};
    this.arithmeticActions = {};
    this.regexActions = {};
};

Action.prototype.addValue = function(varName,value){
    this.values[varName] = value;
    return this;
};

Action.prototype.addArithmetic = function(varName,op,value){
    this.arithmeticActions[varName] = [op,value];
    return this;
}

Action.prototype.addRegex = function(varName,regex,options,replaceValue){
    this.regexActions[varName] = [regex,options,replaceValue];
    return this;
};

module.exports = {
    Rule : Rule,
    Condition : Condition,
    Action : Action
};

});

define('ReteInterface',['require','exports','module','./ReteDataStructures','./ReteActivationAndDeletion','./ReteNetworkBuilding','./ReteComparisonOperators','./ReteUtilities','underscore','./RuleCtors','./ReteActions'],function (require, exports, module) {/**
   @file ReteInterface
   @purpose Provides functions for operating on a retenet object
*/
var RDS = require('./ReteDataStructures'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    ReteNetworkBuilding = require('./ReteNetworkBuilding'),
    RCO = require('./ReteComparisonOperators'),
    ReteUtil = require('./ReteUtilities'),
    _ = require('underscore'),
    RuleCtors = require('./RuleCtors'),
    PossibleActions = require('./ReteActions');




var clearHistory = function(reteNet){
    reteNet.enactedActions = [];
};

var clearPotentialActions = function(reteNet){
    reteNet.potentialActions = [];
};

//Assert a wme RIGHT NOW
var assertWME_Immediately = function(data,reteNet,retractionTime){
    console.log("ASSERTING:",data);
    if(retractionTime === undefined) { retractionTime = 0; }
    if(data.isWME === undefined || data.id === undefined){
        data = new RDS.WME(data,reteNet.currentTime,retractionTime);
        addToRetractionList(reteNet,data,data.lifeTime[1]);
        reteNet.allWMEs[data.id] = data;
    }
    //Actually push the wme into the net
    ReteActivationsAndDeletion.alphaNodeActivation(reteNet.rootAlpha,data);
    return data.id;
};

//Retract a wme RIGHT NOW, clean up its tokens, and any potential actions
var retractWME_Immediately = function(wme,reteNet){
    //console.log("retracting immediately:",wme);
    //if not given the wme directly
    if(wme.isWME === undefined){
        //if given a wme id
        if(Number.isInteger(wme) && reteNet.allWMEs[wme] !== undefined){
            //throw new Error("Not Retracting a wme, or a valid id");
            wme = reteNet.allWMEs[wme];
            //if given a graph node with a related wme
        }else if(wme.wmeId !== undefined && reteNet.allWMEs[wme.wmeId] !== undefined){
            console.log("Retrieving wme using wmeId:",wme.wmeId);
            wme = reteNet.allWMEs[wme.wmeId];
        }else{
            console.log("Unknown:",wme);
            throw new Error("Unknown wme to retract");
        }
    }
    //console.log("Retracting:",wme);
    ReteActivationsAndDeletion.removeAlphaMemoryItemsForWME(wme);
    var invalidatedActions = ReteActivationsAndDeletion.deleteAllTokensForWME(wme);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
    ReteActivationsAndDeletion.deleteAllNegJoinResultsForWME(wme);
    return wme;
};

var modifyWME_Immediately = function(wme,reteNet,modifyFunction){
    retractWME_Immediately(wme,reteNet);
    var data = wme.data;
    //apply the modify function to the data:
    modifyFunction(data);
    assertWME_Immediately(data,reteNet);
};


/**
   @function addWME
   @purpose Creates a wme from the passed in data, schedules it for assertion
   @note There is a difference between ADDING to the net and the initial ACTIVATION of the root
*/
//Assert a wme into the network
var assertWME_Later = function(wmeData,reteNet,assertionTime,retractionTime){
    //Create the wme:
    if(assertionTime === undefined) { assertionTime = reteNet.currentTime; }
    if(retractionTime === undefined) { retractionTime = 0; }
    if(wmeData.isWME === undefined || wmeData.id === undefined){
        wmeData = new RDS.WME(wmeData,assertionTime,retractionTime);
        reteNet.allWMEs[wmeData.id] = wmeData;
    }
    //Add it to the input WME Buffer:
    addToAssertionList(reteNet,wmeData);
    addToRetractionList(reteNet,wmeData);
    //Store it as part of allWMEs:
    return wmeData.id;
};

/**
   @function addToAssertionList
   @purpose to record when a wme needs to be asserted
   @note increment time will use this information
*/
var addToAssertionList = function(reteNet,wme,time){
    if(wme.isWME === undefined){
        if(!Number.isInteger(wme) || reteNet.allWMEs[wme] === undefined){
            throw new Error("Trying to register an invalid wme");
        }
        wme = reteNet.allWMEs[wme];
    }
    if(time === undefined) {
        time = wme.lifeTime[0];
    }else{
        wme.lifeTime[0] = time;
    }
    if(reteNet.wmeLifeTimes.assertions[time] === undefined){
        reteNet.wmeLifeTimes.assertions[time] = [];
    }
    reteNet.wmeLifeTimes.assertions[time].push(wme);
};

/**
   @function addToRetractionList
   @purpose to record when a wme needs to be retracted
   @note increment time will use this information
*/
var addToRetractionList = function(reteNet,wme,time){
    if(wme.isWME === undefined){
        if(!Number.isInteger(wme) || reteNet.allWMEs[wme] === undefined){
            throw new Error("Trying to register an invalid wme");
        }
        wme = reteNet.allWMEs[wme];
    }
    if(time === undefined){
        time = wme.lifeTime[1];
    }else{
        wme.lifeTime[1] = time;
    }
    if(reteNet.wmeLifeTimes.retractions[time] === undefined){
        reteNet.wmeLifeTimes.retractions[time] = [];
    }
    reteNet.wmeLifeTimes.retractions[time].push(wme);
};

/**
   @function incrementTime
   @purpose steps the retenet forwards by one step. retracts then asserts new wmes,
   @TODO figure out if this is in the correct order. should it be the otherway around
*/
var incrementTime = function(reteNet){
    //retract everything scheduled
    console.log("Incrementing time for step:",reteNet.currentTime);
    if(reteNet.wmeLifeTimes.retractions.length > reteNet.currentTime && reteNet.wmeLifeTimes.retractions[reteNet.currentTime] !== undefined){
        reteNet.wmeLifeTimes.retractions[reteNet.currentTime].forEach(function(wme){ retractWME_Immediately(wme,reteNet); });
    }
    console.log("Retractions finished for timeStep:",reteNet.currentTime);
    //assert everything schdeuled
    if(reteNet.wmeLifeTimes.assertions.length > reteNet.currentTime && reteNet.wmeLifeTimes.assertions[reteNet.currentTime] !== undefined){
        reteNet.wmeLifeTimes.assertions[reteNet.currentTime].forEach(function(wme){  assertWME_Immediately(reteNet.rootAlpha,wme,wme.lifeTime[1]); });
    }
    console.log("Assertions finished for timeStep:",reteNet.currentTime);
    
    //At this point: newly activated action instructions are in
    //reteNet.potentialActions,
    //and non-decidable actions are scheduled
    //nothing is asserted immediately to stop infinite inference loops
    
    //increment the time
    reteNet.currentTime++;

};

/**
   @function addRule
   @purpose to build a network for a given rule
   @note Assumes the rule's actions and conditions are objects themselves
   @note allNodes store all relevant objects
   @note see TotalShell::compileRete
*/
var addRule = function(ruleId,reteNet,components){
    if(!Number.isInteger(ruleId) || components[ruleId] === undefined){
        throw new Error("Unrecognised rule id specified");
    }
    var rule = components[ruleId],
        conditions = _.keys(rule.conditions).map(function(d){
            return this[d];
        },components),                
        //build network with a dummy node for the parent
        finalBetaMemory = ReteNetworkBuilding.buildOrShareNetworkForConditions(reteNet.dummyBetaMemory,conditions,reteNet.rootAlpha,components,reteNet),
        //Build the actions that are triggered by the rule:
        actionDescriptions = _.keys(rule.actions).map(function(actionId){
            //console.log("Adding action id:",actionId);
            //todo: protect against duplicates here?
            return components[actionId];
        }),        
        ruleAction = new RDS.ActionNode(finalBetaMemory,actionDescriptions,rule.name,reteNet),
        //Bind actions with descriptions and store in the rule Action:
        boundActionDescriptions = actionDescriptions.map(function(d){
            if(PossibleActions[d.tags.actionType] === undefined){
                throw new Error("Unrecognised action type");
            }
            return _.bind(PossibleActions[d.tags.actionType],d);
        });

    //Add the bound actions into the action node:
    ruleAction.boundActions = boundActionDescriptions;
    

    reteNet.actions[rule.id] = ruleAction;

    return ruleAction;
};

/**
   @function removeRule
   @purpose to remove a rule from the network
*/
var removeRule = function(actionNode,reteNet){
    //delete from bottom up
    var invalidatedActions = ReteActivationsAndDeletion.deleteNodeAndAnyUnusedAncestors(actionNode);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
};


/**
   convert rules to map of components
 */
var convertRulesToComponents = function(rules){
    if(!(rules instanceof Array)){
        rules = [rules];
    }
    var actions = _.flatten(rules.map(function(d){
            return _.values(d.actions);
        })),
        conditions = _.flatten(rules.map(function(d){
            return _.values(d.conditions);
        })),
        all = actions.concat(conditions).concat(rules),
        components = all.reduce(function(m,v){
            m[v.id] = v;
            return m;
        },{});
    return components;
};


var moduleInterface = {
    "CompOperators" : RCO,
    "ConstantTest" : RDS.ConstantTest,
    "ReteNet" : RDS.ReteNet,
    "addRule" : addRule,
    "assertWME_Immediately" : assertWME_Immediately,
    "assertWME_Later" : assertWME_Later,
    "clearHistory" : clearHistory,
    "clearPotentialActions" : clearPotentialActions,
    "convertRulesToComponents" : convertRulesToComponents,
    "incrementTime" : incrementTime,
    "removeRule" : removeRule,
    "retractWME_Immediately" : retractWME_Immediately,
    "Rule" : RuleCtors.Rule,
    "Condition" : RuleCtors.Condition,
    "Action" : RuleCtors.Action,
    "RDS" : RDS
};
module.exports = moduleInterface;    


});


require(["ReteInterface"]);
define('underscore',function() { return _; }); return require('ReteInterface'); }));