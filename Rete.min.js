// wrap-start.frag.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['underscore'], factory);
    } else if (typeof exports === 'object') {
        var _ = require('underscore');
        module.exports = factory(_);
    } else {
        // change "myLib" to whatever your library is called
        root.Rete = factory(root._);
    }
}(this, function (_) {

    
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

define('ReteDataStructures',['require','exports','module','underscore'],function (require, exports, module) {/**
   Defines the data structures required for the Net
   @module ReteDataStructures
   @requires underscore
*/

var _ = require('underscore'),
    nextId = 0;


/**
   Describes a queued, but not yet performed, action
   @param reteNet
   @param type
   @param payload
   @param token
   @param proposeTime
   @param timingObj
   @param priority
   @param tags
   @class ProposedAction
   queue/invalidate time absolute,
   assertTime/retractTime relative to when action is enacted
*/
var ProposedAction = function(reteNet,type,payload,token,proposeTime,timingObj,priority,tags){
    this.id = nextId++;
    this.type = "ProposedAction";
    this.reteNet = reteNet;
    this.actionType = type;//ie: "assert","retract","perform"...
    this.payload = payload; //ie" : {a:3,b:4}...
    this.token = token; //Source Token that spawned this action
    this.timing = {
        proposeTime : proposeTime,//when PA is created
        invalidateTime : proposeTime+timingObj.invalidateOffset, //when it becomes invalid
        performOffset : timingObj.performOffset, //PerformTime+pO is when it happens
        unperformOffset : timingObj.unperformOffset //PerformTime+uPO when to remove
    };
    this.priority = priority || 0;
    this.tags = tags || {};
    //todo: possibly include metrics for selection of actions?
    //todo: check for circular reference cleanup
    //update Token:
    this.token.proposedActions.push(this);
};


/**
   Stores facts in the rete net
   @param data
   @param assertTime
   @class WME
*/
var WME = function(data,assertTime){
    this.id = nextId++;
    this.type = "WME";
    this.data = data;
    //The lifetime of the wme. Asserted at time lifeTime[0],
    //retracted at time lifeTime[1]:
    if(assertTime === undefined) { assertTime = 0; }
    this.lifeTime = [assertTime];
    //Alpha memories the wme is part of
    this.alphaMemoryItems = [];
    //Tokens the wme is part of
    this.tokens = [];
    //Tokens this wme is blocking
    this.negJoinResults = [];
};

/**
   Represents intermediate results in the beta network
   @param parentToken
   @param wme
   @param owningNode
   @param bindings
   @class Token
*/
var Token = function(parentToken,wme,owningNode,bindings){
    this.id = nextId++;
    this.type = "Token";
    //bindings are updated as the token progresses
    this.parentToken = parentToken; //ie:owner
    this.wme = wme;
    this.owningNode = owningNode;
    this.children = []; //list of tokens
    this.negJoinResults = [];//list of blocking NegativeJoinResults
    this.nccResults = []; //list of blocking Tokens
    this.proposedActions = []; //current proposed actions
    
    if(this.parentToken){
        this.parentToken.children.unshift(this);
    }
    if(this.wme && this.wme.tokens){
        this.wme.tokens.unshift(this);
    }

    //copy over bindings from parent,
    //then copy in new bindings
    this.bindings = {};

    if(this.parentToken && this.parentToken.bindings){
        _.keys(this.parentToken.bindings).forEach(function(d){
            this.bindings[d] = this.parentToken.bindings[d];
        },this);
    }
    _.keys(bindings).forEach(function(d){
        this.bindings[d] = bindings[d];
    },this);

};

//------------------------------

/**
   A Pairing of a wme with an alpha memory it resides in
   @param wme
   @param alphaMem
   @class AlphaMemoryItem
*/
//Utility storage of wme and its alphaMemory together
//used in alphamemory and WME
var AlphaMemoryItem = function(wme,alphaMem){
    this.id = nextId++;
    this.type = "AlphaMemoryItem";
    this.wme = wme;
    this.alphaMemory = alphaMem;
};


/**
   A node to perform constant tests on newly asserted WMEs
   constantTest = {field: string, value: string ,operator: string};
   @param parent
   @param constantTestSpec
   @class AlphaNode
*/

var AlphaNode = function(parent,constantTestSpec){
    this.id = nextId++;
    this.type = "AlphaNode";
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.children = [];
    this.outputMemory = undefined;
    if(constantTestSpec){
        this.testField = constantTestSpec.field;
        this.testValue = constantTestSpec.value;
        this.operator = constantTestSpec.operator;
    }else{
        this.passThrough = true;
    }
};

/**
   To store wmes that have passed through constant tests
   @param parent
   @class AlphaMemory
*/
var AlphaMemory = function(parent){
    this.id = nextId++;
    this.type = "AlphaMemory";
    this.items = [];
    this.parent = parent;
    //If adding to a node other than a test node,
    if(this.parent && !(this.parent instanceof AlphaNode)){
        //add to children
        //this.parent.children.unshift(this);
        throw new Error("Adding alpha memory as child of not a test");
    }else if(this.parent && this.parent instanceof AlphaNode && this.parent.outputMemory === undefined){
        //if an alphanode, set the ouputmemory field
        this.parent.outputMemory = this;
    }else{
        throw new Error("trying to create an alpha memory for a node that already has one");
    }
    this.children = [];
    this.unlinkedChildren = [];
    this.referenceCount = 0;
};

/**
   Provides a base definition of a node in the rete network
   @class ReteNode

*/    
//Base node for the beta network
var ReteNode = function(parent){
    this.id = nextId++;
    this.type = "ReteNode";
    this.children = [];
    this.unlinkedChildren = [];
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
};

/**
   A Node to store tokens in the rete network
   @param parent 
   @class BetaMemory
   @augments ReteNode
*/
var BetaMemory = function(parent){
    ReteNode.call(this,parent);
    this.type = "BetaMemory";
    this.items = [];
    if(parent === undefined){
        this.dummy = true;
        this.items.push(new Token());
        this.items[0].owningNode = this;
    }
};

/**
   To combine tokens and wmes, according to binding tests
   @class JoinNode
   @augments ReteNode
*/
var JoinNode = function(parent,alphaMemory,tests){
    //Join Node combines tokens with wmes
    //tests are the binding tuples from a condition
    ReteNode.call(this,parent);
    this.type = "JoinNode";
    this.alphaMemory = alphaMemory;
    if(tests){
        this.tests = tests;
    }else{
        this.tests = [];
    }
    if(this.alphaMemory && this.alphaMemory.children){
        this.alphaMemory.children.unshift(this);
        this.alphaMemory.referenceCount += 1;
    }
    this.nearestAncestor = null;
    this.items = [];
};

/**
   A Node which, when activated, will cause the effects a rule describes
   @param parent
   @param actionDescriptions
   @param boundActions
   @param ruleName
   @param reteNet
   @augments ReteNode
   @class ActionNode
*/
var ActionNode = function(parent,actionDescriptions,boundActions,ruleName,reteNet){
    //Container object for a general graphnode action description    
    ReteNode.call(this,parent);
    this.type = "ActionNode";
    this.name = ruleName;
    this.actionDescriptions = actionDescriptions;
    this.boundActions = boundActions;
    //reference to retenet, to allow storage of results of firing:
    this.reteNet = reteNet;
};


/**
   To Store the combination of a token and a wme that blocks it from progressing through the network
   @param owner the token
   @param wme the wme
   @class NegativeJoinResult
*/
var NegativeJoinResult = function(owner,wme){
    //Storage for a token blocked by a wme
    //Updates the owner token and wme as part of its construction
    this.id = nextId++;
    this.type = "Negative Join Result";
    this.owner = owner;
    if(this.owner){
        this.owner.negJoinResults.unshift(this);
    }
    this.wme = wme;
    if(this.wme){
        this.wme.negJoinResults.unshift(this);
    }
};


/**
   A Node that tests for the abscence of particular wmes
   @param parent
   @param alphaMemory
   @param tests
   @class NegativeNode
   @augments ReteNode
*/
var NegativeNode = function(parent,alphaMemory,tests){
    ReteNode.call(this,parent);
    this.type = "Negative Node";
    this.items = [];
    this.alphaMemory = alphaMemory;
    if(this.alphaMemory){
        this.alphaMemory.referenceCount++;
        this.alphaMemory.children.unshift(this);
    }
    this.tests = tests || [];
    this.nearestAncestor = null;
};

/**
   The generalisation of the negative node to multiple conditions, forms the leaf of a subnetwork
   @param parent
   @class NCCNode
   @augments ReteNode
   @see {@link NCCondition}
*/
var NCCNode = function(parent){
    //NCC : gates token progression based on a subnetwork
    //don't pass parent in so you can PUSH instead of SHIFT
    ReteNode.call(this);
    this.type = "NCCNode";
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.push(this);
    }
    /**
       @type {Array.<RDS.Token>}
     */
    this.items = [];
    this.partner = null;
};


/**
   To store potential partial matches in the subnetwork for a NCCNode.
   @param parent
   @param num
   @class NCCPartnerNode
*/
var NCCPartnerNode = function(parent,num){
    //get the parent if parent is a beta memory to stop redundant node usage
    ReteNode.call(this,parent);
    this.type = "NCCPartnerNode";
    this.nccNode = null;
    this.numberOfConjuncts = num;
    this.newResultBuffer = [];
    this.id = nextId;
};



//--------------------
var DataStructures = {
    "WME"              : WME,
    "Token"            : Token,
    "AlphaMemory"      : AlphaMemory,
    "AlphaMemoryItem"  : AlphaMemoryItem,
    "AlphaNode"        : AlphaNode,
    "ReteNode"         : ReteNode,
    "BetaMemory"       : BetaMemory,
    "JoinNode"         : JoinNode,
    "NegativeJoinResult":NegativeJoinResult,
    "NegativeNode"     : NegativeNode,
    "NCCNode"          : NCCNode,
    "NCCPartnerNode"   : NCCPartnerNode,
    "ActionNode"       : ActionNode,
    "ProposedAction"   : ProposedAction
};

module.exports = DataStructures;


});

define('ReteArithmeticActions',['require','exports','module','underscore'],function (require, exports, module) {/**
   Defines Arithmetic Actions that the retenet can perform
   @module
*/
var _ = require('underscore');


module.exports = {
    /** Add two values */
    "+" : function(a,b){
        return a + b;
    },
    /** Subtract two values */
    "-" : function(a,b){
        return a - b;
    },
    /** Multiply two values */
    "*" : function(a,b){
        return a * b;
    },
    /** Divide two values */
    "/" : function(a,b){
        return a / b;
    },
};





});

define('ReteUtilities',['require','exports','module','underscore','./ReteDataStructures','./ReteArithmeticActions'],function (require, exports, module) {/**
   @module ReteUtilities
   @requires underscore
*/
var _ = require('underscore'),
    RDS = require('./ReteDataStructures'),
    ArithmeticActions = require('./ReteArithmeticActions');


/**
   Reconnects a joinnode with its alpha memory, once the beta memory is populated
   @param node
   @function relinkToAlphaMemory
*/
var relinkToAlphaMemory = function(node){
    //reconnect an unlinked join node to its alpha memory when there are
    //wmes in said alpha memory
    if(!(node instanceof RDS.JoinNode || node instanceof RDS.NegativeNode)){
        throw new Error("trying to relink alpha on something other than a join node or negative node");
    }
    var ancestor = node.nearestAncestor,
        indices = node.alphaMemory.children.map(d=>d.id);

    //While the ancestor is a child of the alpha memory
    while(ancestor && indices.indexOf(ancestor.id) === -1){
        //go up an ancestor if it is unlinked to
        ancestor = findNearestAncestorWithAlphaMemory(ancestor,node.alphaMemory.id);
    }
    
    //When finished, if the ancestor exists:
    if(ancestor !== null){
        var index = node.alphaMemory.children.map(d=>d.id).indexOf(ancestor.id);
        //add the node into the child list in front of the ancestor
        node.alphaMemory.children.splice(index,0,node);
    }else{
        //otherwise just add at the end
        node.alphaMemory.children.push(node);
    }

    //remove from the unlinkedChildren Field
    var nodeIndex = node.alphaMemory.unlinkedChildren.map(d=>d.id).indexOf(node.id);
    node.alphaMemory.unlinkedChildren.splice(nodeIndex,1);
        
};

/**
   Reconnects a join node to its beta memory, once the alpha memory is populated
   @param node
   @function relinkToBetaMemory
*/
var relinkToBetaMemory = function(node){
    //relink an unlinked join node to its betamemory when there are tokens
    //in said memory
    //remove from the unlinked children list
    //and add it into the children
    if(node.parent.unlinkedChildren.length === 0) { return; }
    var index = node.parent.unlinkedChildren.map(d=>d.id).indexOf(node.id);
    if(index > -1){
        node.parent.unlinkedChildren.splice(index,1);
        node.parent.children.unshift(node);
    }
};


/**
   If an alpha memory becomes empty, displace all its children temporarily
   @param alphaMemory
   @function unlinkAlphaMemory
*/
var unlinkAlphaMemory = function(alphaMemory){
    //if the alphaMem has no items: UNLINK
    if(alphaMemory.items.length === 0){
        alphaMemory.children.forEach(function(amChild){
            if(amChild instanceof RDS.JoinNode){
                var index = amChild.parent.children.map(d=>d.id).indexOf(amChild.id);
                //splice out
                var removed = amChild.parent.children.splice(index,1);
                //and store
                amChild.parent.unlinkedChildren.push(removed[0]);
            }
        });
    }
};


/**
   If a beta memory becomes empty, displace all its children temporarily
   @param node
   @function ifEmptyBetaMemoryUnlink
*/
var ifEmptyBetaMemoryUnlink = function(node){
    //Now Essentially switch on: BetaMemory, NegativeNode,
    //NCCNode, and NCCPartnerNode

    //BETAMEMORY
    if(node && (node instanceof RDS.BetaMemory || node instanceof RDS.JoinNode) ){
        //and that betaMemory has no other items
        if(node.items.length === 0){
            //for all the node's children
            node.children.forEach(function(jn){
                if(!(jn instanceof RDS.JoinNode)){ return; }
                var index = jn.alphaMemory.children.map(d=>d.id).indexOf(jn.id);
                if(index !== -1){
                    var removed = jn.alphaMemory.children.splice(index,1);
                    //push it in the unlinked children list
                    jn.alphaMemory.unlinkedChildren.push(removed[0]);
                }
            });
        }
        return true;
    }else{
        return false;
    }        
};

/**
   If a negative node becomes empty, displace its alpha memory's children
   @param node
   @function ifEmptyNegNodeUnlink
*/
var ifEmptyNegNodeUnlink = function(node){
    if(node && node instanceof RDS.NegativeNode){
        //with elements
        if(node.items.length === 0){
            //unlink alpha memory
            var index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
            var removed = node.alphaMemory.children.splice(index,1);
            node.alphaMemory.unlinkedChildren.push(removed[0]);
        }
    }
};

/**
   Compare an existing constant test node to a constant test that wants to be built
   @param node
   @param constantTestSpec
   @function compareConstantNodeToTest
*/
//taking an alpha node and a ConstantTest
var compareConstantNodeToTest = function(node,constantTestSpec){
    if(node.testField !== constantTestSpec.field
       || node.testValue !== constantTestSpec.value){
        return false;
    }
    if(node.operator !== constantTestSpec.operator){
        return false;
    }
    return true;
};

/**
   Compare specified join tests, to see if a join node is the same as one needed
   @param firstTestSet
   @param secondTestSet
   @function compareJoinTests
*/
var CompareJoinTests = function(firstTestSet,secondTestSet){
    try{
        //compare lengths
        if(firstTestSet.length !== secondTestSet.length) { throw "unequal lengths"; }
        for(var i = 0; i < firstTestSet.length; i++){
            var fTest = firstTestSet[i],
                sTest = secondTestSet[i];
            //compare the bound names
            if(fTest[0] !== sTest[0]) { throw "different bound names"; }
            
            //compare the source names
            if(fTest[1][0] !== sTest[1][0]) { throw "different source names"; }
            
            //compare the bind tests
            if(fTest[1][1].length !== sTest[1][1].length) { throw "different binding tests length"; }
            for(var j = 0; fTest[1][1].length; j++){
                if(fTest[1][1][j][0] !== sTest[1][1][j][0]) { throw "different comp operator"; }
                if(fTest[1][1][j][1] !== sTest[1][1][j][1]) { throw "different comp value"; }
            }
        }
    }catch(e){
        return false;
    }
    return true;
};

/**
   To go up the network, to find appropriate beta network elements linked to the alphamemory
   @param node
   @param alphaMemory
   @function findNearestAncestorWithAlphaMemory
*/
var findNearestAncestorWithAlphaMemory = function(node,alphaMemory){
    //recursive

    //base conditions:
    if(node.dummy){ return null;}
    if(node instanceof RDS.JoinNode || node instanceof RDS.NegativeNode){
        if(node.alphaMemory.id === alphaMemory.id){
            return node;
        }
    }
    //switch recursion into the partner clause
    if(node instanceof RDS.NCCNode){
        return findNearestAncestorWithAlphaMemory(node.partner.parent,alphaMemory);
    }
    //recurse:
    return findNearestAncestorWithAlphaMemory(node.parent,alphaMemory);        
};

//--------------------
/**
   Retrieves a value from an object based on a dot style stringstring
   @param wme
   @param dotString
   @function
 */
var retrieveWMEValueFromDotString = function(wme,dotString){
    "use strict";
    //get from the node stored in wme.data the value
    //that the dotString address specifies
    let address = dotString.split("."),
        currLocation = wme.data;
    while(address.length > 0){
        let curr = address.shift();
        if(currLocation[curr] !== undefined){
            currLocation = currLocation[curr];
        }else{
            return null;
        }
    }

    //return the final location arrived at
    return currLocation;
};

/**
   Remove proposed actions from the retenet, and from their owning tokens
   @param invalidatedActions
   @function
*/

var cleanupInvalidatedActions = function(invalidatedActions){
    if(invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined){
        return;
    }
    var reteNet = invalidatedActions[0].reteNet,
        proposedActions = reteNet.proposedActions,
        idList = invalidatedActions.map(d=>d.id);
    //console.log("Cleaning up:",[idList,invalidatedActions,proposedActions]);
    
    //filter out the ids from the proposedActions list
    //also removing them from the owning tokens
    reteNet.proposedActions = _.reject(reteNet.proposedActions,d=>d === undefined || idList.indexOf(d.id) !== -1);
};


/**
   Take a single object that describes a more complex object, and convert it to that more complex object
   @param objDesc
   @param baseObject
   @function objDescToObject
*/
var objDescToObject = function(objDesc,baseObject){
    /* can work on arbitrary depths, will overwrite primitives if later an object is needed
       
       ie: {"values.a" : 5, "values.b" : 10,
       "tags.type" : "rule", "tags.character" : "bob"}
       --->
       {"values": {"a": 5, "b": 10},
       "tags" : {"type" : "rule", "character": "bob"}}
    */
    var newObj = baseObject || {},
        //take the starting object and for all keys
        finalObj = _.keys(objDesc).reduce(function(m,v){
            //split the keys apart
            var keys = v.split(/\./),
                currObj = m,
                currKey;
            //add an object for each key
            while(keys.length > 1){
                currKey = keys.shift();
                if(currObj[currKey] === undefined
                   || typeof currObj[currKey] !== 'object'){
                    currObj[currKey] = {};
                }
                currObj = currObj[currKey];
            }
            currKey = keys.shift();
            currObj[currKey] = objDesc[v];
            return m;
        },newObj);
    return finalObj;
};

/**
   Create new wme data from an action description and a token's bindings
   @param {Action} action
   @param {Token} token
 */
var createNewWMEData = function(action,token){
    "use strict";
    //initialise from the action's 'values' object
    var newWMEData = _.reduce(_.keys(action.values),function(memo,key){
        var v = action.values[key];
        //if the value starts with # or $, look it up in the token list
        memo[key] = v.match(/^[\$#]/) === null ? v : token.bindings[v.slice(1)];
        return memo;
    },{bindings: {} },action),
    //copy in the bindings
        dataPlusBindings = _.reduce(_.keys(token.bindings),function(m,v){
            m.bindings[v] = token.bindings[v];
            return m;
        },newWMEData);
    
    return dataPlusBindings;
};

/**
   Apply arithmetic actions to a data object, in place
   @param {Action} action
   @param {Object} data
 */
var applyArithmetic = function(action,data){
    "use strict";
    //perform arithmetic:
    _.keys(action.arithmeticActions).forEach(function(key){        
        var arithDesc = action.arithmeticActions[key];
        var currVal = Number(data[key]),
            //look up the function:
            //because the representation form is: a : ["+", 5]
            arithFunc = ArithmeticActions[arithDesc[0]],
            //Get the value if its a binding
            applyVal = typeof arithDesc[1] === 'number' ? arithDesc[1] : arithDesc[1].match(/\$/) ? parseInt(data.bindings[arithDesc[1].slice(1)]) : parseInt(arithDesc[1]);
        if(arithFunc === undefined) { throw new Error("Undefined arithmetic function"); }
        if(isNaN(currVal) || isNaN(applyVal)) { throw new Error("Arithmetic value should be convertable to a number"); }
        data[key] = arithFunc(currVal,applyVal);
    });
};

/**
   Apply an actions Regex transforms to some data, in place
   @param {Action} action
   @param {Object} data
 */
var applyRegex = function(action,data){
    "use strict";
    _.keys(action.regexActions).forEach(function(key){
        var regexAction = action.regexActions[key],
            regex = new RegExp(regexAction[0],regexAction[1]),
            replaceValue = regexAction[2].match(/\$/) ? data.bindings[regexAction[2].slice(1)] : regexAction[2];
        data[key] = data[key].replace(regex,replaceValue);
    });

};


//------------------------------
var moduleInterface = {
    "unlinkAlphaMemory" : unlinkAlphaMemory,
    "relinkToAlphaMemory" : relinkToAlphaMemory,
    "ifEmptyBetaMemoryUnlink" : ifEmptyBetaMemoryUnlink,
    "ifEmptyNegNodeUnlink" : ifEmptyNegNodeUnlink,
    "relinkToBetaMemory" : relinkToBetaMemory,
    "compareJoinTests" : CompareJoinTests,
    "compareConstantNodeToTest" : compareConstantNodeToTest,
    "findNearestAncestorWithAlphaMemory" : findNearestAncestorWithAlphaMemory,
    "retrieveWMEValueFromDotString" : retrieveWMEValueFromDotString,
    "cleanupInvalidatedActions" : cleanupInvalidatedActions,
    "objDescToObject" : objDescToObject,
    "createNewWMEData" : createNewWMEData,
    "applyArithmetic" : applyArithmetic,
    "applyRegex" : applyRegex
};
module.exports = moduleInterface;    


});

define('ReteComparisonOperators',['require','exports','module'],function (require, exports, module) {/**
   To define the possible operators available for constant test nodes
   @module ReteComparisonOperators
*/

//Define an object of comparisons able to
//be used in constant tests

//See general utils file for converting to string
//TODO: These can be changed to their actual representations, similar to reteArithActions
var ConstantTestOperators = {
    "EQ" : function(a,b){
        return a===b;
    },
    "LT" : function(a,b){
        return a < b;
    },
    "GT" : function(a,b){
        return a > b;
    },
    "LTE" : function(a,b){
        return a <= b;
    },
    "GTE": function(a,b){
        return a >= b;
    },
    "NE" : function(a,b){
        return a !== b;
    },
    "MATCH" : function(a,b){
        var regex = new RegExp(b);
        return regex.test(a);
    }
};

ConstantTestOperators['==='] = ConstantTestOperators.EQ;
ConstantTestOperators['<'] = ConstantTestOperators.LT;
ConstantTestOperators['>'] = ConstantTestOperators.GT;
ConstantTestOperators['<='] = ConstantTestOperators.LTE;
ConstantTestOperators['>='] = ConstantTestOperators.GTE;
ConstantTestOperators['!=='] = ConstantTestOperators.NE;
ConstantTestOperators['~='] = ConstantTestOperators.MATCH;


module.exports = ConstantTestOperators;

});

define('ReteTestExecution',['require','exports','module','./ReteDataStructures','underscore','./ReteUtilities','./ReteComparisonOperators'],function (require, exports, module) {/**
   @module ReteTestExecution
   @requires ReteDataStructures
   @requires underscore
   @requires ReteUtilities
   @requires ReteComparisonOperators
 */
var RDS = require('./ReteDataStructures'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    ReteComparisonOps = require('./ReteComparisonOperators');


/**
   Compare a token and wme, using defined bindings from a joinNode
   @param joinNode
   @param token
   @param wme   
   @function performJoinTests
   @returns {False | Object}
*/
var performJoinTests = function(joinNode,token,wme){
    //returns False if no match, dict of all updated bindings otherwise
    var newBindings = {},
        successState = true,
        varRegex = new RegExp(/^[#\$]/);
    //Populate with current bindings from token
    _.keys(token.bindings).forEach(function(key){
        newBindings[key] = token.bindings[key];
    });

    try{
        //add new bindings:
        joinNode.tests.forEach(function(test){
            var newValue = null;
            //retrieve the value
            if(/^[#\$]id$/.test(test[1][0])){
                newValue = wme.id;
            }else{
                newValue = ReteUtil.retrieveWMEValueFromDotString(wme,test[1][0]);
            }
            
            //compare the value for each specified binding test
            var bindingComparisons = test[1][1];
            
            //Compare using any defined binding tests
            bindingComparisons.forEach(function(d){
                var comparator = ReteComparisonOps[d[0]],
                    varName = d[1];
                //if it fails, fail the test
                //use the value in the test, minus the $ at the beginning:
                if(!varRegex.test(varName)) { throw new Error("Non-bound var name"); }
                
                if(!comparator(newValue,newBindings[varName.slice(1)])){
                    throw new Error("Test failed");
                }
            });
            
            if(newBindings[test[0]] === undefined){
                newBindings[test[0]] = newValue;
            }
            if(newBindings[test[0]] !== newValue){
                throw new Error("Test failed");
            }
        });
        
        if(successState){
            return newBindings;
        }else{
            throw new Error("Test failed");
        }
    }catch(e){
        return false;
    }
};


var moduleInterface = {
    "performJoinTests" : performJoinTests,
};
module.exports =  moduleInterface;

});

define('ReteActionAssert',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {/**
   Defines the Assert Action
   @module ReteActionAssert
   @requires ReteArithmeticActions
   @requires ReteUtilities
   @requires ReteDataStructures
   @requires underscore
*/

var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');


/**
   @implements {module:ReteActionInterface}
   @class AssertAction
 */
var AssertAction = {
    "name" : "assert",
    propose : null,
    perform : null
};

/**
   Propose the Assertion
   @param {module:ReteDataStructures.Token} token The token that is emitted by the network
   @param {module:ReteClassInterface.ReteNet} reteNet The top level reteNet
   @function
 */
AssertAction.propose = function(token,reteNet){
    "use strict";
    //create the data object:
    var newWMEData = reteNet.utils.createNewWMEData(this,token);
    reteNet.utils.applyArithmetic(this,newWMEData);
    reteNet.utils.applyRegex(this,newWMEData);
        //Expand out to object structure
    //ie: {values.a:5, tags.type: rule} -> {values:{a:5},tags:{type:rule}}
    var complexFormData = reteNet.utils.objDescToObject(newWMEData);
    
    //To be returned to activateActionNode
    var proposedAction = new reteNet.ProposedAction(reteNet,"assert", complexFormData, token,
                                                reteNet.currentTime,
                                                this.timing,
                                                this.priority
                                                );

    return proposedAction;        
};

/**
   Perform the Assertion, after having been scheduled
   @param {module:ReteDataStructures.ProposedAction} proposedAction
   @param {module:ReteClassInterface.ReteNet} reteNet
   @function
   @return {Object}
 */
AssertAction.perform = function(proposedAction,reteNet){
    "use strict";
    //check the type matches
    if(proposedAction.actionType !== 'assert') { throw new Error("Expected Assert"); }
    //Perform the action:
    var newWMEID = reteNet.assertWME(proposedAction.payload,proposedAction.retractTime);

    //schedule the retraction:
    if(proposedAction.timing.unperformOffset > 0){
        //schedule a retract, with no invalidate time (its not being proposed)
        //and the perform time being the original actions unperformoffset
        reteNet.addToSchedule(new RDS.ProposedAction(reteNet,"retract",newWMEID,null,reteNet.currentTime,{
            invalidateOffset : null,
            performOffset : proposedAction.timing.unperformOffset,
            unperformOffset : null
        }));
    }

    return {
        "asserted" : newWMEID
    };
};

/** The Assert Action Definition */
module.exports = AssertAction;

});

define('ReteActionRetract',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {/**
   Defines the Retract Action
   @module ReteActionRetract
   @requires ReteArithmeticActions
   @requires ReteUtilities
   @requires ReteDataStructures
   @requires underscore
*/
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');



/**
   @class RetractAction
   @implements {ReteActionInterface}
 */
var RetractAction = {
    "name" : "retract",
    propose : null,
    perform : null
};

/**
   Propose the Retraction
   @function
 */
RetractAction.propose = function(token,reteNet){
    //get all wmes the token touches:
    var wmes = [];
    var currToken = token;
    while(currToken && currToken.wme !== undefined){
        wmes.push(currToken.wme);
        currToken = currToken.parentToken;
    }
    //Get the keys of the action that have 'wme' in them
    var wmeKeys = _.keys(this.values).filter(d=>/^wme([0-9]*)/.test(d)),
        //get the ones of those that related to a binding in the token
        wmeIdBindings = wmeKeys.map(d=>this.values[d]).filter(d=>/^\$/.test(d)),
        //get the value for those bindings
        wmeIds = wmeIdBindings.map(d=>token.bindings[d.slice(1)]);
    //console.log("Token bindings :",token.bindings);
    //console.log("Retrieved wme ids for retraction:",wmeIds);
    // //filter the wmeList by the wmeIDs:
    // var toRetract = _.filter(wmes,function(wme){
    //     return _.contains(wmeIDs,wme.id);
    // });

    //Propose the list of all wmes to retract 
    var proposedAction = new RDS.ProposedAction(reteNet,"retract", wmeIds, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;
};

/**
   Perform the retraction
   @function
 */
RetractAction.perform = function(proposedAction,reteNet){
    if(proposedAction.actionType !== 'retract') { throw new Error("Expected retract"); }
    //console.log("Retracting:",proposedAction.payload);
    if(proposedAction.payload instanceof Array){
        var retractedWMEs = proposedAction.payload.map(d=>reteNet.retractWME(d));
        return {
            "retracted" : retractedWMEs
        };
    }else{
        var retractedWME = reteNet.retractWME(proposedAction.payload);
        return {
            "retracted" : [retractedWME]
        };
    }
    //do anything with the retracted wme(s)?

};

/** The Retract Action Definition */
module.exports = RetractAction;

});

define('ReteAction_AddRule',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');



var ActionInterface = {
    "name" : "addRule",
    propose : null,
    perform : null
};

//Token + Action Description -> ProposedAction
ActionInterface.propose = function(token,reteNet){
    "use strict";
    //Propose the list of all wmes to retract 
    var proposedAction = new RDS.ProposedAction(reteNet,"NO-OP", toRetract, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;
};

//ProposedAction -> Performance
ActionInterface.perform = function(proposedAction,reteNet){
    "use strict";
    console.log("No-op");
};


module.exports = ActionInterface;

});

define('ReteAction_removeRule',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');



var ActionInterface = {
    "name" : "removeRule",
    propose : null,
    perform : null
};

//Token + Action Description -> ProposedAction
ActionInterface.propose = function(token,reteNet){
    //Propose the list of all wmes to retract 
    var proposedAction = new RDS.ProposedAction(reteNet,"NO-OP", toRetract, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;
};

//ProposedAction -> performance
ActionInterface.perform = function(proposedAction,reteNet){
    console.log("No-op");
};


module.exports = ActionInterface;

});

define('ReteActions',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures','./ReteActionAssert','./ReteActionRetract','./ReteAction_AddRule','./ReteAction_removeRule'],function (require, exports, module) {/**
   Aggregates ReteNet Actions that implement {@link module:ReteActionInterface}
   @module ReteActions
*/
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures'),
    AssertAction = require('./ReteActionAssert'),
    RetractAction = require('./ReteActionRetract'),
    AddRuleAction = require('./ReteAction_AddRule'),
    RemoveRuleAction = require('./ReteAction_removeRule');



//Action node possible actions:
//Stores both performance functions and proposal functions
//in the form: { name : {name: "", performFunc : func, propseFunc : func } }
var ActionInterface = {};

//Performance functions take a retenet, and a payload
//proposal functions are bound to an action description, and take a token and a retenet

//eg: the action asserts a new wme, with an arithmetic action of +2,
//the action has the information (+ 2), the incoming token as the base value to add to.

//Proposal functions return an object of the form:
//{ action: "", payload: {}, (timeData)? }


//** @action assert
ActionInterface[AssertAction.name] = AssertAction;
//** @action retract
ActionInterface[RetractAction.name] = RetractAction;

//** @action AddRule
ActionInterface[AddRuleAction.name] = AddRuleAction;

//** @action removeRule
ActionInterface[RemoveRuleAction.name] = RemoveRuleAction;


module.exports = ActionInterface;


});

define('ReteActivationAndDeletion',['require','exports','module','./ReteDataStructures','./ReteComparisonOperators','./ReteUtilities','./ReteTestExecution','./ReteActions','underscore'],function (require, exports, module) {/**
   Functions that describe Activation of ReteNet nodes, and the removal of said nodes
   @module ReteActivationAndDeletion
   @requires ReteDataStructures
   @requires ReteComparisonOperators
   @requires ReteUtilities
   @requires ReteTestExecution
   @requires ReteActions
   @requires underscore
 */
var RDS = require('./ReteDataStructures'),
    ConstantTestOperators = require('./ReteComparisonOperators'),
    ReteUtil = require('./ReteUtilities'),
    ReteTestExecution = require('./ReteTestExecution'),
    PossibleActions = require('./ReteActions'),
    _ = require('underscore');



/**
   Stores a wme in an alpha memory, 
   Trigger an alpha memory with a new wme to store
   @param alphaMem
   @param wme
   @function alphaMemoryActivation
*/
var alphaMemoryActivation = function(alphaMem,wme){
    "use strict";
    let newItem = new RDS.AlphaMemoryItem(wme,alphaMem);
    alphaMem.items.unshift(newItem);
    wme.alphaMemoryItems.unshift(newItem);
    //console.log("AlphaMemory activated:",alphaMem,wme);
    let alphaMemChildren = _.clone(alphaMem.children);
    alphaMemChildren.forEach(child=>rightActivate(child,wme));
};

/**
   Tests a wme against the test in the given node
   @param alphaNode
   @param wme
   @function constantTestNodeActivation
*/
var constantTestNodeActivation = function(alphaNode,wme){
    //test the wme using the constant test in the node
    var testResult = false;
    if(alphaNode.passThrough){
        testResult = true;
    }else{
        var wmeFieldValue = ReteUtil.retrieveWMEValueFromDotString(wme,alphaNode.testField),
            value = alphaNode.testValue,
            operator = alphaNode.operator;
        if(wmeFieldValue === null){ return false; }
        if(ConstantTestOperators[operator]){
            if(operator !== 'EQ' && operator !== 'NE'){
                testResult = ConstantTestOperators[operator](Number(wmeFieldValue),Number(value));
            }else{
                //console.log("testing:",wmeFieldValue,operator,value,alphaNode,wme);
                testResult = ConstantTestOperators[operator](wmeFieldValue,value);
            }
            
        }
    }
    if(testResult){
        //console.log("successful constant test result",testResult,wme,alphaNode);
        if(alphaNode.outputMemory){
            alphaNodeActivation(alphaNode.outputMemory,wme);
        }
        alphaNode.children.forEach(child=>alphaNodeActivation(child,wme));
    }
    //console.log("ConstantTest Result:",alphaNode,wme,testResult);
    return testResult;
};

/**
   Selects whether to store a wme, or test the wme
   @param alphaNode
   @param wme
   @function alphaNodeActivation
*/
//Switchable activation function for alpha network stuff
var alphaNodeActivation = function(alphaNode,wme){
    if(alphaNode instanceof RDS.AlphaMemory){
        alphaMemoryActivation(alphaNode,wme);
    }else if(alphaNode instanceof RDS.AlphaNode){
        return constantTestNodeActivation(alphaNode,wme);
    }else{
        throw new Error("Unrecognised node:",alphaNode);
    }
};

/**
   Stores a token in the beta memory
   @param betaMemory
   @param token
   @function betaMemoryActivation
*/
var betaMemoryActivation = function(betaMemory,token){
    "use strict";
    //trigger a beta memory to store a new token
    //bindings are from the join node, holding results of the NEW binding tests
    //old bindings are still in the token, the constructor of Token will combine the two
    //sets of bindings
    let newToken = token;
    betaMemory.items.unshift(newToken);
    let betaMemoryChildren = _.clone(betaMemory.children);
    betaMemoryChildren.forEach(child=>leftActivate(child,newToken));
};


/**
   Given a new token, compares it to all wmes in the related alpha memory
   @param node
   @param token
   @function joinNodeLeftActivation
*/
var joinNodeLeftActivation = function(node,token){
    "use strict";
    //Trigger a join node with a new token
    //will pull all wmes needed from the linked alphaMemory
    //If necessary, relink or unlink the
    //parent betamemory or alphamemory
    if(node.parent.items && node.parent.items.length === 1){
        ReteUtil.relinkToAlphaMemory(node);
        if(node.alphaMemory.items.length === 0){
            //unlink beta memory if alphamemory is empty
            let index = node.parent.children.map(d=>d.id).indexOf(node.id),
                unlinked = node.parent.children.splice(index,1);
            node.parent.unlinkedChildren.push(unlinked[0]);
        }
    }
    //for each wme in the alpha memory,
    //compare using join tests,
    //and pass on successful combinations
    //to beta memory /negative node children
    //to be combined into tokens
    node.alphaMemory.items.forEach(function(item){
        let currWME = item.wme,
            joinTestResult = ReteTestExecution.performJoinTests(node,token,currWME);
        if(joinTestResult !== undefined && joinTestResult !== false){
            let newToken = new RDS.Token(token,currWME,node,joinTestResult);
            node.items.unshift(newToken);
            node.children.forEach(child=>leftActivate(child,newToken));            
        }
    });//end of looping all wmes in alphamemory
};

/**
   @function joinNodeRightActivation
   @param node
   @param wme
   @purpose given a new wme, compares it against all tokens in the related beta memory
*/
//Trigger a join node with a new wme
//pulling all necessary tokens from the parent as needed
var joinNodeRightActivation = function(node,wme){
    "use strict";
    //relink or unlink as necessary
    if(node.alphaMemory.items.length === 1){
        ReteUtil.relinkToBetaMemory(node);
        if(node.parent.items.length === 0){
            let index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id),
                unlinked = node.alphaMemory.children.splice(index,1);
            node.alphaMemory.unlinkedChildren.push(unlinked[0]);
        }
    }

    //For all tokens, compare to the new wme,
    //pass on successful combinations to betamemory/negative node
    node.parent.items.forEach(function(currToken){
        if(currToken.negJoinResults.length > 0 || currToken.nccResults.length > 0){
            return false;
        }
        //console.log("--------\nComparing: ",currToken.bindings,"\n To: ",wme.data,"\n using: ",node.tests);
        let joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            let newToken = new RDS.Token(currToken,wme,node,joinTestResult);
            node.items.unshift(newToken);
            let nodeChildren = _.clone(node.children);
            nodeChildren.forEach(d=>leftActivate(d,newToken));
        }
    });
};


/**
   Given a new token, proposes a set of actions
   @param actionNode
   @param token
   @function activateActionNode
*/
var actionNodeActivation = function(actionNode,token){
    //get the actions the node embodies:
    var boundActionFunctions = actionNode.boundActions,
        //apply the token to each of the actions
        newProposedActions = boundActionFunctions.map(d=>d(token,actionNode.reteNet)),
        newProposedActionIds = newProposedActions.map(d=>d.id);
    //store the proposed actions in the reteNet.potential actions
    //and also tie all the actions that fire together by their ids
    //ie: {action:"assert",payload:wme}
    //see RDS.ProposedAction for details
    newProposedActions.forEach(function(d){
        d.parallelActions = _.reject(newProposedActionIds,e=>e===d.id);
        actionNode.reteNet.proposeAction(d);
    });
};


/**
   Selects what node to activate as appropriate, for a new token
   @function leftActivate
*/
var leftActivate = function(node,token,wme,joinTestResults){
    //Utility leftActivation function to call
    //whichever specific type is needed
    //Construct a new token if supplied the correct
    //parameters
    if(!(node instanceof RDS.JoinNode || node instanceof RDS.ActionNode)){
        token = new RDS.Token(token,wme,node,joinTestResults);
    }
    //owning node is the node going into, rather than coming out of

    //Activate the node:
    //Essentially a switch of:
    //betaMemory, JoinNode, NegativeNode, NCC, PartnerNode, and action
    if(node.__isDummy){
        //pass on, because this is a test
    }else if(node instanceof RDS.BetaMemory){
        betaMemoryActivation(node,token);
    }else if(node instanceof RDS.JoinNode){
        joinNodeLeftActivation(node,token);
    }else if(node instanceof RDS.NegativeNode){
        negativeNodeLeftActivation(node,token);
    }else if(node instanceof RDS.NCCNode){
        nccNodeLeftActivation(node,token);
    }else if(node instanceof RDS.NCCPartnerNode){
        nccPartnerNodeLeftActivation(node,token);
    }else if(node instanceof RDS.ActionNode){
        actionNodeActivation(node,token);
    }else{
        throw new Error("Unknown node type leftActivated");
    }
    return token;
};

/**
   Selects what node to activate, given a new wme
   @param node
   @param wme
   @function rightActivate
*/
var rightActivate = function(node,wme){
    if(node instanceof RDS.JoinNode){
        joinNodeRightActivation(node,wme);
    }else if(node instanceof RDS.NegativeNode){
        negativeNodeRightActivation(node,wme);
    }else{
        throw new Error("Tried to rightActivate Unrecognised node");
    }
};

/**
   Activate a negative node with a new token
   @param node
   @param newToken
   @function negativeNodeLeftActivation
*/
var negativeNodeLeftActivation = function(node,newToken){
    "use strict";
    //Trigger a negative node from a new token
    //brings in bindings, creates a new token as necessary,
    //combining bindings to.

    //Relink
    //console.log("Negative node left activation");
    if(node.items.length === 0){
        ReteUtil.relinkToAlphaMemory(node);
    }
    node.items.unshift(newToken);

    node.alphaMemory.items.forEach(function(item){
        var currWme = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,newToken,currWme);
        if(joinTestResult){
            //adds itself to the token and
            //wme as necessary to block the token
            var joinResult = new RDS.NegativeJoinResult(newToken,currWme);
        }
    });

    //if no wmes block the token, pass it on down the network
    if(newToken.negJoinResults.length === 0){
        let nodeChildren = _.clone(node.children);
        nodeChildren.forEach(child=>leftActivate(child,newToken));
    }
    
};

/**
   Activate a negative node with a new wme
   @param node
   @param wme
   @function negativeNodeRightActivation
*/
var negativeNodeRightActivation = function(node,wme){
    //trigger a negative node from a new wme,
    //getting all tokens stored, comparing to the wme.
    //any that the wme blocks, gets an additional negative Join result
    //any that don't get blocked should already have been activated
    console.log("Negative node right activation");
    node.items.forEach(function(currToken){
        if(currToken.negJoinResults.length > 0 || currToken.nccResults.length > 0){
            return false;
        }
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            if(currToken.negJoinResults.length === 0){
                //todo: fix this
                var invalidatedActions = deleteDescendentsOfToken(currToken);
                ReteUtil.cleanupInvalidatedActions(invalidatedActions);
            }
            //Adds itself to the currToken and wme as
            //necessary
            var negJoinResult = new RDS.NegativeJoinResult(currToken,wme);
        }
    });
};

/**
   Activate a Negated Conjunctive Condition with a new Token
   @param nccNode
   @param token
   @function nccNodeLeftActivation
*/
var nccNodeLeftActivation = function(nccNode,token){
    "use strict";
    //from a new token, trigger the subnetwork?
    //Create and store the incoming token from prior join node
    if(!(nccNode instanceof RDS.NCCNode)){
        throw new Error("nccNodeLeftActivation should be on an NCCNode");
    }
    if(!(token instanceof RDS.Token)){
        throw new Error("nccNodeLeftActivation should be on a token");
    }
    var newToken = token;
    nccNode.items.unshift(newToken);

    //the partner's network MUST fire before the nccnode
    //hence this. all the new results' in the partners new result buffer,
    //are from the same origin as token
    //if there are new results to process:
    while(nccNode.partner && nccNode.partner.newResultBuffer.length > 0){
        var newResult = nccNode.partner.newResultBuffer.pop();
        //add the subnetworks result as a blocking token
        newToken.nccResults.unshift(newResult);
        //set the subnetwork result to have its parent as the new token
        newResult.parentToken = newToken;
    }

    //if the new token has no blocking tokens,
    //continue on
    if(newToken.nccResults.length === 0){
        let nccNodeChildren = _.clone(nccNode.children);
        nccNodeChildren.forEach(child=>leftActivate(child,newToken));
    }
};

/**
   Activate a Negated Conjunctive Condition's subnetwork with a new token
   @param partner
   @param token
   @function nccPartnerNodeLeftActivation
*/
var nccPartnerNodeLeftActivation = function(partner,token){
    //the nccPartnerNode is activated by a new token from the subnetwork
    //figure out who owns this new token from the main (positive) network
    //the partner's ncc
    var nccNode = partner.nccNode,
        //the token created in left activate, with partner as owner
        newToken = token,
        ownersToken = token.parentToken,//the prior token
        ownersWme = token.wme,//the prior wme
        owner;

    for(var i = 0; i < partner.numberOfConjuncts; i++){
        //go up the owner chain
        ownersWme = ownersToken.wme;
        ownersToken = ownersToken.parentToken;
    }

    //find an owner in the ncc node's memory to link to
    if(nccNode !== undefined && ownersToken && ownersWme){
        var possible_tokens = _.reject(nccNode.items,function(d){
            return d.parentToken.id !== ownersToken.id || (d.wme && d.wme.id !== ownersWme.id);
        });
        if(possible_tokens.length > 0){
            owner = possible_tokens[0];
        }
    }

    //link the owner and the new token
    if(owner !== undefined){
        //the necessary owner exists in the nccNode,
        //so update it:
        owner.nccResults.unshift(newToken);
        newToken.parentToken = owner;
        var invalidatedActions = deleteDescendentsOfToken(owner);
        ReteUtil.cleanupInvalidatedActions(invalidatedActions); 
    }else{        
        //else no owner: add to temp buffer to wait for the ncc node to be activated
        partner.newResultBuffer.unshift(newToken);
    }
};


/**
   Utility function to activate based on lack of existence of negated join results
   @param nJR
   @function activateIfNegatedJRIsUnblocked
*/
var activateIfNegatedJRIsUnblocked = function(nJR){
    "use strict";
    var currJoinResult = nJR;
    //if the negation clears, activate it
    if(currJoinResult.owner.negJoinResults.length === 0){
        let owningNodeChildren = _.clone(currJoinResult.owner.owningNode.children);
        owningNodeChildren.forEach(child=>leftActivate(child,currJoinResult.owner));
    }
};


/**
   To remove a wme from all alpha memories it is stored in
   postCondition wme.alphaMemoryItems is empty
   @param wme
   @function removeAlphaMemoryItemsForWME   
*/
var removeAlphaMemoryItemsForWME = function(wme){
    //remove alpha memory items
    wme.alphaMemoryItems.forEach(function(item){
        //unlink the alphamemory from the item
        item.alphaMemory.items = _.reject(item.alphaMemory.items,d=>d.id===item.id);
        //unlink the alphaMemory itself if it is now empty
        //will unlink if am.items.length === 0
        ReteUtil.unlinkAlphaMemory(item.alphaMemory);
        //clear the item's links
        item.alphaMemory = undefined;
        item.wme = undefined;
    });
    //completely clear am items:
    wme.alphaMemoryItems = [];
};

/**
   To cleanup all tokens a wme is part of
   @param wme
   @function deleteAllTokensForWME
*/
var deleteAllTokensForWME = function(wme){
    var invalidatedActions = new Set();
    //For all tokens
    while(wme.tokens.length > 0){
        deleteTokenAndDescendents(wme.tokens[0]).forEach(d=>invalidatedActions.add(d));
    }
    return Array.from(invalidatedActions);
};

/**
   For negative conditions, discount the wme as a block
   @param wme
   @function deleteAllNegJoinResultsForWME
*/
var deleteAllNegJoinResultsForWME = function(wme){
    //unlink the negative Join results in the owning token
    wme.negJoinResults.forEach(function(jr){
        jr.owner.negJoinResults = _.reject(jr.owner.negJoinResults,d=>d.id === jr.id);
        activateIfNegatedJRIsUnblocked(jr);
        //remove internal references:
        jr.owner = undefined;
        jr.wme = undefined;
    });
    //completely clear negjoinresults
    wme.negJoinResults = [];
};


/**
   To delete any blocked tokens in negative conditions
   @param token
   @function removeNegJoinResultsForToken
*/
var removeNegJoinResultsForToken = function(token){
    //remove Negative join results
    token.negJoinResults.forEach(function(jr){
        jr.wme.negJoinResults = _.reject(jr.wme.negJoinResults,d=>d.id === jr.id);
        //clear the references
        jr.wme = undefined;
        jr.token = undefined;
    });
    token.negJoinResults = [];
};


/**
   To remove a token from whatever node created it
   @param token
   @function removeTokenFromNode
*/
//Now the utility functions for deleteing token:
var removeTokenFromNode = function(token){
    //Deal with if the owning node is NOT an NCC
    if(token.owningNode
       && !(token.owningNode instanceof RDS.NCCPartnerNode)){
       //&& (token.owningNode instanceof RDS.AlphaMemory || token.owningNode instanceof RDS.BetaMemory)){
        //by removing the token as an element in that node
        token.owningNode.items = _.reject(token.owningNode.items,d=>d.id === token.id);
    }
};

/**
   To clean a token up, removing it from any WME references
   @function removeTokenFromWME
*/
var removeTokenFromWME = function(token){
    //remove the token from the wme it is based on
    if(token.wme && token.wme.tokens){
        token.wme.tokens = _.reject(token.wme.tokens,d=>d.id === token.id);
    }
};

/**
   Cleanup the token from its parents list
   @param token
   @function removeTokenFromParentToken
*/
var removeTokenFromParentToken = function(token){
    //Remove the token from it's parent's child list
    if(token && token.parentToken){
        token.parentToken.children = _.reject(token.parentToken.children,d=>d.id === token.id);
    }
};

/**
   Cleanup an unused node and any parent nodes that are also unused once this node is gone.
   @param node
   @function deleteNodeAndAnyUnusedAncestors
*/
var deleteNodeAndAnyUnusedAncestors = function(node){
    "use strict";
    /*
      Do a number of things:
      clean up tokens stored in a node
      remove any reference to the node from a connected alpha
      remove any reference to the node from a parent
      
      +: call recursively on any parent that has no children
    */
    var invalidatedActions = new Set();
    if(node instanceof RDS.ActionNode){
        node.reteNet = null;
    }
    
    //if NCC, delete partner too
    if(node instanceof RDS.NCCNode){
        let tempPartner = node.partner;
        node.partner = null;
        deleteNodeAndAnyUnusedAncestors(tempPartner).forEach(d=>invalidatedActions.add(d));
    }
    
    //clean up tokens
    if((node instanceof RDS.BetaMemory && node.dummy === undefined) || (node instanceof RDS.NegativeNode) || (node instanceof RDS.NCCNode) || (node instanceof RDS.JoinNode)){
        while(node.items.length > 0){
            let curr = node.items.pop();
            deleteTokenAndDescendents(curr).forEach(d=>invalidatedActions.add(d));
        }
    }
    if(node instanceof RDS.NCCPartnerNode){
        while(node.newResultBuffer.length > 0){
            let curr = node.newResultBuffer.pop();
            deleteTokenAndDescendents(curr).forEach(d=>invalidatedActions.add(d));
        }
    }

    //clean up any associated alphamemory
    if(node.alphaMemory && (node instanceof RDS.JoinNode || node instanceof RDS.NegativeNode)){
        node.alphaMemory.children = _.reject(node.alphaMemory.children,d=>d.id===node.id);
        node.alphaMemory.unlinkedChildren = _.reject(node.alphaMemory.unlinkedChildren,d=>d.id===node.id);
        node.alphaMemory.referenceCount--;

        if(node.alphaMemory.referenceCount < 1){
            let tempAlphaMemory = node.alphaMemory;
            node.alphaMemory = null;
            deleteAlphaNode(tempAlphaMemory).forEach(d=>invalidatedActions.add(d));
        }
    }

    //remove the node from its parent
    if(node.parent){
        //check the child list:
        node.parent.children = _.reject(node.parent.children,d=>d.id===node.id);
        node.parent.unlinkedChildren = _.reject(node.parent.unlinkedChildren,d=>d.id===node.id);
    }

    //delete parent node if its got no children
    if(node.parent && node.parent.children.length === 0
       && node.parent.unlinkedChildren
       && node.parent.unlinkedChildren.length === 0
       && node.parent.dummy === undefined){
        let tempParent = node.parent;
        node.parent = null;
        deleteNodeAndAnyUnusedAncestors(tempParent).forEach(d=>invalidatedActions.add(d));
    }

    //delete any children to be sure
    node.children.forEach(d=>deleteNodeAndAnyUnusedAncestors(d).forEach(e=>invalidatedActions.add(e)));
    node.unlinkedChildren.forEach(d=>deleteNodeAndAnyUnusedAncestors(d).forEach(ed=>invalidatedActions.add(e)));
    
    //deallocate memory for none

    node.cleanup = true; //schedule for cleanup in the retenet
    
    return Array.from(invalidatedActions);
};


/**
   Simplification of removing children of a token, but not the token itself
   @param token
   @function deleteDescendentsOfToken
*/
//utility function to delete all descendents without deleting the token
var deleteDescendentsOfToken = function(token){
    var invalidatedActions = new Set();
    while(token.children.length > 0){
        var curr = token.children.pop();
        deleteTokenAndDescendents(curr).forEach(d=>invalidatedActions.add(d));
    }
    token.proposedActions.forEach(d=>invalidatedActions.add(d));
    return Array.from(invalidatedActions);
};


/**
   @param token
   @function deleteTokenAndDescendents
*/
var deleteTokenAndDescendents = function(token){
    "use strict";
   /* purpose To remove a token and clean it 
   delete a token and all the tokens that rely on it
   a bit of a frankenstein. Deletes the token,
   deletes descendents, but also sets and cleans up 
   left unlinking of join nodes, AND
   activates NCC's that are no longer blocked
   */
    var invalidatedActions = new Set();
    //Recursive call:
    while(token.children.length > 0){
        var curr = token.children.pop();
        deleteTokenAndDescendents(curr).forEach(d=>invalidatedActions.add(d));
    }

    //Base Cases:
    //remove memory items
    removeTokenFromNode(token);
    removeTokenFromWME(token);
    removeTokenFromParentToken(token);
    
    ReteUtil.ifEmptyBetaMemoryUnlink(token.owningNode);
    ReteUtil.ifEmptyNegNodeUnlink(token.owningNode,token.id);

    removeNegJoinResultsForToken(token);

    cleanupNCCResultsInToken(token);
    cleanupNCCPartnerOwnedToken(token);

    if(token && token.owningNode
       && token.owningNode instanceof RDS.NCCPartnerNode
       && token.parentToken.nccResults.length === 0){
        //Activate newly unblocked Token
        //todo: should this be nccnode AND/OR negNode?
        let nccNodeChildren = _.clone(token.owningNode.nccNode.children);
        nccNodeChildren.forEach(d=>leftActivate(d,token.parentToken));
    }

    //get the queued actions linked with the token, and return them for cleanup
    token.proposedActions.forEach(d=>invalidatedActions.add(d));
    return Array.from(invalidatedActions);
};

/**
   @param token
   @function cleanupNCCResultsInToken
*/
var cleanupNCCResultsInToken = function(token){
    //NCCNODE
    //for all the nccResult tokens, delete them
    token.nccResults.forEach(function(nccR){
        //remove the nccR token from its linked wme
        if(nccR.wme){
            nccR.wme.tokens = _.reject(nccR.wme.tokens,d=>d.id === nccR.id);
        }
        if(nccR.parentToken){
            //remove the token from it's parent
            nccR.parentToken.children = _.reject(nccR.parentToken.children,d=>d.id === nccR.id);
        }
    });
    //clear the nccResults
    token.nccResults = [];
};

/**
   @param token
   @function cleanupNCCPartnerOwnedToken
*/
var cleanupNCCPartnerOwnedToken = function(token){
    //NCCPARTNERNODE
    if(token.owningNode
       && token.owningNode instanceof RDS.NCCPartnerNode
       && token.parentToken){
        //remove from owner.nccResults:
        token.parentToken.nccResults = _.reject(token.parentToken.nccResults,d=>d.id === token.id);
        token.owningNode.newResultBuffer = _.reject(token.owningNode.newResultBuffer,d=>d.id === token.id);
        return true;
    }else{
        return false;
    }
};

var deleteAlphaNode = function(alphaNode){
    "use strict";
    var invalidatedActions = new Set();
    if(alphaNode instanceof RDS.AlphaNode && alphaNode.children.length === 0 && alphaNode.outputMemory === null && alphaNode.passThrough === undefined){
        alphaNode.testField = null;
        alphaNode.testValue = null;
        alphaNode.operator = null;
        alphaNode.parent.children = _.reject(alphaNode.parent.children,d=>d.id === alphaNode.id);
        let oldParent = alphaNode.parent;
        alphaNode.parent = null;
        deleteAlphaNode(oldParent).forEach(d=>invalidatedActions.add(d));
        alphaNode.cleanup = true;
    }else if(alphaNode instanceof RDS.AlphaMemory){
        alphaNode.children.forEach(d=>deleteNodeAndAnyUnusedAncestors(d));
        alphaNode.unlinkedChildren.forEach(d=>deleteNodeAndAnyUnusedAncestors(d));
        alphaNode.children = [];
        alphaNode.unlinkedChildren = [];

        let itemIds = alphaNode.items.map(d=>d.id),
            itemWMEs = alphaNode.items.map(d=>d.wme);
        itemWMEs.forEach(function(d){
            d.alphaMemoryItems = _.reject(d.alphaMemoryItems,e=>itemIds.indexOf(e.id) > -1);
        });
        alphaNode.items = [];
        let oldParent = alphaNode.parent;
        oldParent.outputMemory = null;
        alphaNode.parent = null;
        deleteAlphaNode(oldParent).forEach(d=>invalidatedActions.add(d));
        alphaNode.cleanup = true;
    }    
    return Array.from(invalidatedActions);
};


var moduleInterface = {
    "deleteDescendentsOfToken" : deleteDescendentsOfToken,
    "removeAlphaMemoryItemsForWME" : removeAlphaMemoryItemsForWME,
    "deleteAllTokensForWME" : deleteAllTokensForWME,
    "deleteAllNegJoinResultsForWME" : deleteAllNegJoinResultsForWME,
    "deleteNodeAndAnyUnusedAncestors" : deleteNodeAndAnyUnusedAncestors,
    "leftActivate" : leftActivate,
    "rightActivate" : rightActivate,
    "alphaNodeActivation" : alphaNodeActivation,
    "activateIfNegatedJRIsUnblocked" : activateIfNegatedJRIsUnblocked,
};
module.exports = moduleInterface;

});

define('ReteNetworkBuilding',['require','exports','module','./ReteDataStructures','./ReteUtilities','./ReteActivationAndDeletion','underscore'],function (require, exports, module) {/**
   Functions to create the actual Alpha and Beta Networks of the ReteNet
   @module ReteNetworkBuilding
   @requires ReteDataStructures
   @requires ReteUtilities
   @requires ReteActivationAndDeletion
   @requires underscore
 */
var RDS = require('./ReteDataStructures'),
    ReteUtil = require('./ReteUtilities'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    _ = require('underscore');


/**
   To add all given conditions to the network
   @param parent
   @param conditions
   @param rootAlpha
   @param allNodes
   @param reteNet
   @function buildOrShareNetworkForConditions

*/
var buildOrShareNetworkForConditions = function(parent,conditions,rootAlpha,allNodes,reteNet){
    "use strict";
    let currentNode = parent,
        alphaMemory;
    //for each condition
    conditions.forEach(function(condition){
        if(condition.tags.type !== 'rule' && condition.tags.type !== 'condition'){
            throw new Error("trying to add something that isnt a condition");
        }
        if(condition.tags.type === 'condition' && condition.tags.conditionType === undefined){
            throw new Error("Trying to add a condition without a conditionType");
        }
        
        //get the binding tests for join nodes
        let tests = _.pairs(condition.bindings);
        
        if(condition.tags.conditionType === 'positive'){
            //Build a positive condition:
            //currentNode = buildOrShareBetaMemoryNode(currentNode,reteNet);
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareJoinNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.conditionType === 'negative'){
            //Build a negative condition:
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareNegativeNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.conditionType === 'negConjCondition'){
            //Build a Negated Conjunctive Condition
            currentNode = buildOrShareNCCNodes(currentNode,condition,rootAlpha,allNodes,reteNet);
        }else if(condition.tags.type === 'rule'){
            //for using other rules as composable conditions
            let ruleConditions = _.keys(condition.conditions).map(d=>allNodes[d]);
            currentNode = buildOrShareNetworkForConditions(currentNode,ruleConditions,rootAlpha,allNodes,reteNet);
        }else{
            console.error("Problematic Condition:",condition);
            throw new Error("Unrecognised condition type");
        }
    });

    //build a final memory node if current isn't one
    return buildOrShareBetaMemoryNode(currentNode,reteNet);
};

/**
   Reuse, or create a new, constant test node, for the given test
   @param parent
   @param constantTestSped
   @param reteNet
   @function buildOrShareConstantTestNode
*/
var buildOrShareConstantTestNode = function(parent,constantTestSpec,reteNet){
    "use strict";
    let children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        let node = children[i];
        if(ReteUtil.compareConstantNodeToTest(node,constantTestSpec)){
            return node;
        }
    }
    //No existing, create a new node:
    let newAlphaNode = new RDS.AlphaNode(parent,constantTestSpec);
    reteNet.storeNode(newAlphaNode);
    return newAlphaNode;
};


/**
   Create alpha network as necessary, stick an alpha memory on the end
   @param condition
   @param root
   @param allNodes
   @param reteNet
   @function buildOrShareAlphaMemory
*/   
var buildOrShareAlphaMemory = function(condition,root,allNodes,reteNet){
    "use strict";
    //Rule{Conditions[]}, Condition{constantTests:[],bindings:[[]]}
    let currentNode = root,
        constantTests = condition.constantTests;//[{field:,op:,value:}]
    
    currentNode = constantTests.reduce(function(m,v){
        return buildOrShareConstantTestNode(m,v,reteNet);
    },currentNode);
    
    //see if there is an existing memory for this condition.
    //if so, return existing alphamemory
    if(currentNode.outputMemory !== undefined){
        return currentNode.outputMemory;
    }
    //else: create the alpha memory
    //ctor will update the current node's outputMemory field
    let newAlphaMemory = new RDS.AlphaMemory(currentNode);
    //run wmes in working memory against the alpha network
    reteNet.storeNode(newAlphaMemory);
    return newAlphaMemory;
};

/**
   Given a node (ie: join), stick a betamemory on it as a child
   @param parent
   @param reteNet
   @function buildOrShareBetaMemoryNode
*/
var buildOrShareBetaMemoryNode = function(parent,reteNet){
    "use strict";
    //if passed in the dummy top node, OR any sort of memory node,
    //be it NCC,Negative,NCCPartner
    if(parent instanceof RDS.BetaMemory || parent instanceof RDS.NCCPartnerNode || parent instanceof RDS.NegativeNode || parent instanceof RDS.NCCNode || parent instanceof RDS.JoinNode){
        return parent;
    }
    
    //if theres an available beta memory to use,
    //return that
    let children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        let child = children[i];
        if(child instanceof RDS.BetaMemory){
            return child;
        }
    }
    //else: create a new beta memory
    //ctor should update  parent's children
    let newBetaMemory = new RDS.BetaMemory(parent);
    //update it with matches
    updateNewNodeWithMatchesFromAbove(newBetaMemory);
    reteNet.storeNode(newBetaMemory);
    //return new beta memory
    return newBetaMemory;
};

/**
   To reuse, or create a new, join node linking an alpha memory and betamemory
   @param parent
   @param alphaMemory
   @param tests
   @param reteNet
   @function buildOrShareJonNode
*/
var buildOrShareJoinNode = function(parent,alphaMemory,tests,reteNet){
    "use strict";
    //convert tests if necessary:
    if(!(tests instanceof Array)){
        tests = _.pairs(tests);
    }
    
    //see if theres a join node to use already
    let allChildren = parent.children.concat(parent.unlinkedChildren);
    for(var i = 0; i < allChildren.length; i++){
        let child = allChildren[i];
        if(child instanceof RDS.JoinNode && child.alphaMemory && child.alphaMemory.id === alphaMemory.id && ReteUtil.compareJoinTests(child.tests,tests)){
            //return it
            return child;
        }
    }
    //else: create a new join node
    //increment alphamemories reference count in the constructor
    let newJoinNode = new RDS.JoinNode(parent,alphaMemory,tests);
    //set the nearest ancestor
    newJoinNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);

    //if either parent memory is empty, unlink
    if(parent.items.length === 0){
        //BETA IS EMPTY: UNLINK RIGHT
        let index = alphaMemory.children.map(d=>d.id).indexOf(newJoinNode.id),
            removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.unshift(removed[0]);
    }else if(alphaMemory.items.length === 0){
        //ALPHA IS EMPTY: UNLINK LEFT
        let newNodeIndex = parent.children.map(d=>d.id).indexOf(newJoinNode.id),
            removedNode = parent.children.splice(newNodeIndex,1);
        parent.unlinkedChildren.unshift(removedNode[0]);
    }
    //return new join node
    reteNet.storeNode(newJoinNode);
    
    return newJoinNode;
};

/**
   To reuse, or build a new, negative node
   @param parent
   @param alphaMemory
   @param tests
   @param reteNet
   @function buildOrShareNegativeNode
*/
var buildOrShareNegativeNode = function(parent,alphaMemory,tests,reteNet){
    "use strict";
    if(!(tests instanceof Array)) { tests = _.pairs(tests); }
    //see if theres an existing negative node to use
    let children = _.values(parent.children);
    for(var i = 0; i < children.length; i ++){
        let child = children[i];
        if(child instanceof RDS.NegativeNode
           && child.alphaMemory
           && child.alphaMemory.id === alphaMemory.id
           && ReteUtil.compareJoinTests(child.tests,tests)){
            return child;
        }
    }
    let newNegativeNode = new RDS.NegativeNode(parent,alphaMemory,tests);
    newNegativeNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);
    //update with matches
    updateNewNodeWithMatchesFromAbove(newNegativeNode);
    //unlink if it has no tokens
    if(newNegativeNode.items.length === 0){
        let index = alphaMemory.children.map(d=>d.id).indexOf(newNegativeNode.id),
            removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.push(removed[0]);
    }
    //return new negative node

    reteNet.storeNode(newNegativeNode);
    return newNegativeNode;
};

/**
   Construction of NCCConditions
   @param parent
   @param condition
   @param rootAlpha
   @param allNodes
   @param reteNet
   @function buildOrShareNCCNodes

*/
var buildOrShareNCCNodes = function(parent,condition,rootAlpha,allNodes,reteNet){
    "use strict";
    if(condition.tags.conditionType !== 'negConjCondition'){
        throw new Error("BuildOrShareNCCNodes only takes NCCCondition");
    }
    //build a network for the conditions
    let conditions = _.keys(condition.conditions).map(d=>allNodes[d]),
        //build the subnetwork
        bottomOfSubNetwork = buildOrShareNetworkForConditions(parent,conditions,rootAlpha,allNodes,reteNet);
    //find an existing NCCNode with partner to use
    for(var i = 0; i < parent.children.length; i++){
        let child = parent.children[i];
        if(child instanceof RDS.NCCNode && child.partner.parent && child.partner.parent.id === bottomOfSubNetwork.id){
            return child;
        }
    }
    
    //else: build NCC and Partner nodes
    let newNCC = new RDS.NCCNode(parent),
        newNCCPartner = new RDS.NCCPartnerNode(bottomOfSubNetwork,_.keys(condition.conditions).length);

    newNCC.partner = newNCCPartner;
    newNCCPartner.nccNode = newNCC;
    //update NCC
    updateNewNodeWithMatchesFromAbove(newNCC);
    //update partner
    updateNewNodeWithMatchesFromAbove(newNCCPartner);

    reteNet.storeNode(newNCC);
    reteNet.storeNode(newNCCPartner);
    
    return newNCC;
};


/**
   Pulls tokens down from parent upon new creation
   @note Possible race conditions?
   @param newNode
   @function updateNewNodeWithMatchesFromAbove
*/
var updateNewNodeWithMatchesFromAbove = function(newNode){
    //essentially a 4 state switch:
    //betaMemory, joinNode, negativeNode, NCC
    "use strict";
    let parent = newNode.parent;
    if(parent instanceof RDS.BetaMemory){
        for(let i = 0; i < parent.items.length; i++){
            ReteActivationsAndDeletion.leftActivate(newNode,parent.items[i]);
        }
    }else if(parent instanceof RDS.JoinNode){
        let savedChildren = parent.children,
            items = _.values(parent.alphaMemory.items);
        parent.children = [newNode];
        for(let i = 0; i < items.length; i++){
            let item = items[i];
            ReteActivationsAndDeletion.rightActivate(parent,item.wme);
        }
        parent.children = savedChildren;
    }else if(parent instanceof RDS.NegativeNode){
        let items = _.values(parent.items);
        for(let i = 0; i < items.length; i++){
            let token = items[i];
            if(token.negJoinResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }else if(parent instanceof RDS.NCCNode){
        let items = _.values(parent.items);
        for(let i = 0; i < items.length; i++){
            let token = parent.items[i];
            if(token.nccResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }
};



var moduleInterface = {
    "buildOrShareNetworkForConditions" : buildOrShareNetworkForConditions,
};
module.exports =  moduleInterface;


});

define('RuleCtors',['require','exports','module'],function (require, exports, module) {/**
   Constructors for in-library creation of rules
   @module RuleCtors
*/

var nextId = 0;

/**
   Rule Ctor. Holds conditions and actions
   @class
*/
var Rule = function(name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { type : "rule" };
    this.conditions = {};
    this.actions = {};
};

/**
   Creates a condition and adds it to the rule
   @param type
   @param testsAndBindings
   @method
   @returns this
 */
Rule.prototype.newCondition = function(type,testsAndBindings){
    //testsAndBindings = { tests : [ [var,op,val]...], bindings : [ [var,val,[op,var]]] }
    var newCondition = new Condition(type);
    //Add all tests
    if(testsAndBindings.tests !== undefined){
        testsAndBindings.tests.forEach(d=>newCondition.addTest(...d));
    }
    if(testsAndBindings.bindings !== undefined){
        testsAndBindings.bindings.forEach(d=>newCondition.addBinding(...d));
    }
    this.addCondition(newCondition);
    return this;
};

/**
   Creates and adds an action to the rule
   @param type
   @param name
   @param valuesArithRegexsAndTiming
   @method
   @returns this
 */
Rule.prototype.newAction = function(type,name,valuesArithRegexsAndTiming){
    //valuesArithRegexsAndTiming = { values : [], arith : [], regexs : [], timing : [], priority : n}
    var newAction = new Action(type,name);
    if(valuesArithRegexsAndTiming.values !== undefined){
        valuesArithRegexsAndTiming.values.forEach(d=>newAction.addValue(...d));
    }
    if(valuesArithRegexsAndTiming.arith !== undefined){
        valuesArithRegexsAndTiming.arith.forEach(d=>newAction.addArithmetic(...d));
    }
    if(valuesArithRegexsAndTiming.regexs !== undefined){
        valuesArithRegexsAndTiming.regexs.forEach(d=>newAction.addRegex(...d));
    }
    if(valuesArithRegexsAndTiming.priority !== undefined){
        newAction.priority = valuesArithRegexsAndTiming.priority;
    }
    if(valuesArithRegexsAndTiming.timing !== undefined){
        newAction.addTiming(...valuesArithRegexsAndTiming.timing);
    }
    this.addAction(newAction);
    return this;
};

Rule.prototype.addCondition = function(condition){
    this.conditions[condition.id] = condition;
    return this;
};

Rule.prototype.addAction = function(action){
    this.actions[action.id] = action;
    return this;
};

/**
   Condition Ctor. Holds tests, bindings, and other conditions
   @param type
   @class
 */
var Condition = function(type){
    this.id = nextId++;
    this.name = "conditon";
    type = type === undefined ? "positive" : type;
    switch(type){
    case "positive":
        this.tags = { type : "condition",
                      conditionType : 'positive' };
        break;
    case "negative":
        this.tags = { type : "condition",
                      conditionType : 'negative' };
        break;
    case "ncc":
        this.tags = { type : 'condition',
                      conditionType : "negConjCondition" };
        break;
    default:
        throw new Error("Unrecognised condition");
    }
    this.constantTests = [];
    this.bindings = {};
    this.conditions = {};    
};

/**
   Adds a test to the condition
   @param field
   @param op
   @param val
   @method
 */
Condition.prototype.addTest = function(field,op,val){
    this.constantTests.push({
        field : field,
        operator : op,
        value : val
    });
    return this;
};

/**
   Adds a binding to the condition
   @param boundName
   @param dataName
   @param tests
   @method
 */
Condition.prototype.addBinding = function(boundName,dataName,tests){
    //tests as pairs of op and value/boundName
    this.bindings[boundName] = [dataName,tests];
};

/**
   Adds a new subcondiiton to the condition
   @param type
   @param testsAndBindings
   @method
 */
Condition.prototype.newCondition = function(type,testsAndBindings){
    if(this.type !== 'negConjCondition') { throw new Error("Only NCC's can have sub conditions"); }
    var newCondition = new Condition(type);
    testsAndBindings.tests.forEach(d=>newCondition.addTest(...d));
    testsAndBindings.bindings.forEach(d=>newCondition.addBinding(...d));
    this.conditions[newCondition.id] = newCondition;
};

/**
   Action constructor, defines data/values to put in a new wme,
   arithmetic and regex actions to apply to those values
   @param actionType
   @param name
   @class
 */
var Action = function(actionType,name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { actionType : actionType || "assert" };
    this.values = {};
    this.arithmeticActions = {};
    this.regexActions = {};
    //Specify the timing of the proposed action to create:
    this.timing = {
        invalidateOffset : 0,
        performOffset : 0,
        unperformOffset : 0
    };
    this.priority = 0;
};

/**
   Add a value to the action
   @param varName
   @param value
   @method
 */
Action.prototype.addValue = function(varName,value){
    this.values[varName] = value;
    return this;
};

/**
   Add an arithmetic modification to the action
   @param varName
   @param op
   @param value
   @method
*/
Action.prototype.addArithmetic = function(varName,op,value){
    this.arithmeticActions[varName] = [op,value];
    return this;
};

/**
   Add a regular expression modification to the action
   @param varName
   @param regex
   @param options
   @param replaceValue
   @method
*/
Action.prototype.addRegex = function(varName,regex,options,replaceValue){
    this.regexActions[varName] = [regex,options,replaceValue];
    return this;
};

/**
   Add timing information to the action
   @param invalid
   @param perform
   @param unperform
   @method
 */
Action.prototype.addTiming = function(invalid,perform,unperform){
    this.timing = {
        invalidateOffset : invalid,
        performOffset : perform,
        unperformOffset : unperform
    };
    return this;
};


module.exports = {
    Rule : Rule,
    Condition : Condition,
    Action : Action
};

});

define('ReteClassInterface',['require','exports','module','underscore','./ReteDataStructures','./ReteNetworkBuilding','./ReteActivationAndDeletion','./ReteUtilities','./RuleCtors','./ReteActions','./ReteComparisonOperators','./ReteArithmeticActions'],function (require, exports, module) {/**
   Defines a class based ReteNet interface
   @module ReteClassInterface
   @requires ReteDataStructures
   @requires ReteNetworkBuilding
   @requires ReteActivationAndDeletion
   @requires ReteUtilities
   @requires RuleCtors
   @requires ReteActions
   @requires ReteComparisonOperators
   @requires ReteArithmeticActions
 */

var _ = require('underscore'),
    RDS = require('./ReteDataStructures'),
    ReteNetworkBuilding = require('./ReteNetworkBuilding'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    ReteUtil = require('./ReteUtilities'),
    RuleCtors = require('./RuleCtors'),
    ReteActions = require('./ReteActions'),
    ComparisonOperators = require('./ReteComparisonOperators'),
    ArithmeticOperators = require('./ReteArithmeticActions');

/**
   The General controller for a retenet
   @constructor
   @param actionsToRegister
*/
var ReteNet = function(actionsToRegister){
    if(actionsToRegister === undefined){
        actionsToRegister = [];
    }
    /** 
        The starting BetaMemory of the retenet
        @member {module:ReteDataStructures.BetaMemory} dummyBetaMemory
        @private
    */
    this.dummyBetaMemory = new RDS.BetaMemory();
    /**
       The starting alpha node of the retenet
       @member {module:ReteDataStructures.AlphaNode} rootAlpha
       @private
     */
    this.rootAlpha = new RDS.AlphaNode();

    /**
       The available actions the retenet can perform
       {name: string ,perform : function, propose : function };
       @member {Object} 
       @see {@link module:ReteActions}
    */
    this.actionFunctions = _.clone(ReteActions);

    /** @alias {module:RuleCtors.Rule} */
    this.Rule = RuleCtors.Rule;
    /** @see {module:ReteComparisonOperators} */
    this.ComparisonOperators = ComparisonOperators;
    /** @see {module:ReteArithmeticActions} */
    this.ArithmeticOperators = ArithmeticOperators;
    /** @see {module:ReteDataStructures.ProposedAction} */
    this.ProposedAction = RDS.ProposedAction;
    /** @see {module:ReteDataStructures.WME} */
    this.WME = RDS.WME;
    /** @see {module:ReteDataStructures.Token} */
    this.Token = RDS.Token;
    /** @see {module:ReteUtilities} */
    this.utils = ReteUtil;
    /**
       All rules loaded into the ReteNet
       @member {Object}
       @see {@link module:RuleCtors.Rule}
     */
    this.allRules = {};
    /**
       Constructed ActionNodes of the ReteNet
       @member {Object}
       @see {@link module:ReteDataStructures.ActionNode}
     */
    this.actions = {};
    /**
       All WMEs that exist in the ReteNet
       @member {Object}
       @see {@link module:ReteDataStructures.WME}
     */
    this.allWMEs = {};

    /**
       All Proposed Actions, from ActionNodes that have fired, indexed by id
       @member {Object}
       @see {@link module:ReteDataStructure.ProposedActions}
     */
    this.proposedActions = {};
    /**
       All Actions that were schedule and then performed
       @member {Array} 
       @see {@link module:ReteDataStructures.ProposedActions}
     */
    this.enactedActions = [];

    /**
       All nodes of the ReteNet, enabling inspection
       @member {Object}        
     */
    this.allReteNodes = {};
    /**
       All ReteNodes, indexed by type
       todo: make this a weak map?
       @member {Object} 
     */
    this.allReteNodesByType = {};

    /**
       The current time step of the retenet
       @member {Int}
     */
    this.currentTime = 1;
    /**
       The Actions that have been scheduled
       @member {Object}
     */
    this.schedule = {
        assertions : [],
        retractions : [],
        modifications: []
    };

    /**
       Listeners that have been registered for various occurences
       @member {Object}
     */
    this.listeners = {
        "propose" : [],
        "assert" : [],
        "retract" : [],
        "addRule" : [],
        "removeRule" : [],
        "schedule" : [],
        "stepTimeActions" : [],
    };

    //Register actions passed in:
    actionsToRegister.forEach(function(d){
        this.registerAction(d);
    },this);
    
    
};
//--------------------
//METHODS:
//--------------------

//Utility to register listeners:
/**
   Register a function for a retenet occurent
   @param {string} name The occurrence type to listen for
   @param {function} fn The function to trigger when the occurrence happens
   @method
 */
ReteNet.prototype.registerListener = function(name,fn){
    if(this.listeners[name] !== undefined){
        this.listeners[name].push(fn);
    }
};

/**
   Trigger all registered listeners for an occurence
   @param {string} name The name of the occurrence that happened
   @param ...vals The parameters to pass to the listener functions
   @method
 */
ReteNet.prototype.fireListener = function(name,...vals){
    if(this.listeners[name] === undefined){
        throw new Error(`Unrecognised listener fired: ${name}`);
    }
    //call the registered functions
    this.listeners[name].forEach(d=>d(...vals));
};


/**
   Stores a wme in the retenet
   @param {WME} wme
   @private
 */
ReteNet.prototype.storeWME = function(wme){
    this.allWMEs[wme.id] = wme;
};

/**
   Clears the history of actions that have been performed
   @method
 */
ReteNet.prototype.clearHistory = function(){
    this.enactedActions = [];
};

/**
   Clear the proposed actions list
   @method
 */
ReteNet.prototype.clearProposedActions = function(){
    this.proposedActions = {};
};

/**
   Assert a wme immediately
   @param {WME/Object} wme The wme or data to assert
   @return {Int} WME.id
   @method
 */
ReteNet.prototype.assertWME = function(wme){
    this.fireListener("assert",wme);
    //console.log("ASSERTING:",wme);
    if(!(wme instanceof RDS.WME)){
        wme = new RDS.WME(wme,this.currentTime);
        this.storeWME(wme);
    }
    //Actually push the wme into the net
    ReteActivationsAndDeletion.alphaNodeActivation(this.rootAlpha,wme);
    return wme.id;
};

/**
   Retract a wme immediately
   @param {wme/id} wme The wme object or id to retract
   @method
 */
ReteNet.prototype.retractWME = function(wme){
    this.fireListener("retract",wme);
    //console.log("retracting immediately:",wme);
    //if not given the wme directly
    if(!(wme instanceof RDS.WME)){
        //if given a wme id
        if(Number.isInteger(wme) && this.allWMEs[wme] !== undefined){
            wme = this.allWMEs[wme];
            //if given a graph node with a related wme
        }else if(wme.wmeId !== undefined && this.allWMEs[wme.wmeId] !== undefined){
            console.log("Retrieving wme using wmeId:",wme.wmeId);
            wme = this.allWMEs[wme.wmeId];
        }else{
            console.log("Unknown:",wme);
            throw new Error("Unknown wme to retract");
        }
    }
    //console.log("Retracting:",wme);
    ReteActivationsAndDeletion.removeAlphaMemoryItemsForWME(wme);
    var invalidatedActions = ReteActivationsAndDeletion.deleteAllTokensForWME(wme);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
    ReteActivationsAndDeletion.deleteAllNegJoinResultsForWME(wme);
    //Record when the wme was retracted
    wme.lifeTime[1] = this.currentTime;

    delete this.allWMEs[wme.id];
    return wme;
};

/**
   Retract, change, and then assert some data
   @param {WME/id} wme The wme to retract
   @param {function} modifyFunction The function that changes the data of the wme
   @method
 */
ReteNet.prototype.modifyWME = function(wme,modifyFunction){
    var retractedWME = this.retractWME(wme),
        data = retractedWME.data,
        modifiedData = modifyFunction(data);
    if(modifiedData === undefined || modifiedData === null) {
        throw new Error("Modify function must return the new data");
    }
    return this.assertWME(modifiedData);
    
};

/**
   Propose an action, typically from an action node
   @param {module:ReteDataStructures.ProposedAction} action
   @method
 */
ReteNet.prototype.proposeAction = function(action){
    //Call the listeners:
    this.fireListener("propose",action);
    
    if(action instanceof Array){
        action.forEach(d=>this.proposeAction(d));
        return;
    }
    if(this.proposedActions[action.id] !== undefined){
        throw new Error("Proposing a duplicate action");
    }
    //console.log("Proposing:",action);
    this.proposedActions[action.id] = action;
};

/**
   Schedule an action by it's ID, ALSO scheduling any parallel actions   
   @param  {module:ReteDataStructures.ProposedAction|Int} actionId The action to propose
   @method
 */
ReteNet.prototype.scheduleAction = function(actionId){
    this.fireListener("schedule",actionId);
    if(actionId instanceof this.ProposedAction){
        this.scheduleAction(actionId.id);
        return;
    }
    if(this.proposedActions[actionId] === undefined){
        throw new Error("Invalid action specified: " + actionId);
    }
    var action = this.proposedActions[actionId],
        parallelActions = action.parallelActions.map(d=>this.proposedActions[d]);

    this.addToSchedule(action);
    parallelActions.forEach(d=>this.addToSchedule(d));
    return this;
};

/**
   Internal method to add to the schedule
   @param {module:ReteDataStructures.ProposedAction} action
   @method
   @private
 */
ReteNet.prototype.addToSchedule = function(action){
    if(action.actionType === undefined || action.payload === undefined || action.timing === undefined){
        throw new Error("Scheduling action failure");
    }
    if(this.schedule[action.actionType] === undefined){
        this.schedule[action.actionType] = [];
    }
    var performTime = this.currentTime + action.timing.performOffset;
    if(this.schedule[action.actionType][performTime] === undefined){
        this.schedule[action.actionType][performTime] = [];
    }
    this.schedule[action.actionType][performTime].push(action);
    //Action is no longer proposed, so remove it from the token
    action.token.proposedActions = _.reject(action.token.proposedActions,d=>d.id===action.id);
    //also remove it from retenet's proposed actions:
    delete this.proposedActions[action.id];
};

/**
   Step Time forward. actions should be scheduled BEFORE CALLING STEP TIME.
   @method
   @returns {Array} An array of the effects of this timestep
*/
ReteNet.prototype.stepTime = function(){
    //get all actions scheduled at the current timepoint
    var actions = _.values(this.schedule),
        actionsForTimePoint = _.reject(_.flatten(actions.map(d=>d[this.currentTime])),d=>d===undefined);
    //todo : group by tags:
    
    //Sort by priority
    actionsForTimePoint.sort((a,b)=>b.priority - a.priority);
    
    this.fireListener('stepTimeActions',actionsForTimePoint);
    //perform those actions, storing objects describing the changes
    var changes = actionsForTimePoint.map(function(d){
        var performanceFunction = this.actionFunctions[d.actionType].perform;
        var effects = performanceFunction(d,this);
        this.enactedActions.push(d);
        return effects;
    },this);

    //cleanup invalidated actions
    _.values(this.proposedActions).forEach(function(d){
        if(d.timing.invalidateTime === this.currentTime){
            delete this.proposedActions[d.id];
        }
    });
    
    this.currentTime++;

    return changes;
};

/**
   Add a rule to the retenet, auto converting to correct format if necessary, returning [ReteNet,{@link{module:ReteDataStructures.ActionNode}]
   @param {Array | int | module:RuleCtors.Rule} ruleId The rule/rules to add
   @param {Object} components An object to lookup components of rules in
   @method
   @returns {Array}
   
*/
ReteNet.prototype.addRule = function(ruleId,components){
    this.fireListener("addRule",components);
    if(ruleId instanceof Array){
        return ruleId.map(d=>this.addRule(d,components));
    }
    if(ruleId instanceof this.Rule){
        var convertedComponents = this.convertRulesToComponents(ruleId);
        return this.addRule(ruleId.id,convertedComponents);
    }
    if(!Number.isInteger(ruleId) || components[ruleId] === undefined){
        throw new Error("Unrecognised rule id specified");
    }
    //-----------
    //Add a single rule:
    var rule = components[ruleId],
        //TODO: support rules as conditions by flattening the conditions repeatedly
        conditions = _.keys(rule.conditions).map(d=>components[d]),
        //build network with a dummy node for the parent
        finalMemoryNode = ReteNetworkBuilding.buildOrShareNetworkForConditions(this.dummyBetaMemory,conditions,this.rootAlpha,components,this),
        //Get the action descriptions that are triggered by the rule:
        //TODO: support rules as actions by repeatedly flattening
        actionDescriptions = _.keys(rule.actions).map(d=>components[d]),
        //Bind proposalFuncs with actionDescriptions
        boundActionDescriptions = actionDescriptions.map(function(d){
            if(this.actionFunctions[d.tags.actionType] === undefined){
                throw new Error("Unrecognised action type");
            }
            return _.bind(this.actionFunctions[d.tags.actionType].propose,d);
        },this),
        //Create the action, with the bound action functions
        ruleAction = new RDS.ActionNode(finalMemoryNode,actionDescriptions,boundActionDescriptions,rule.name,this);
    
    //Add the bound actions into the action node:
    ruleAction.ruleId = rule.id;
    ruleAction.boundActions = boundActionDescriptions;
    this.actions[ruleAction.ruleId] = ruleAction;
    this.allRules[ruleAction.ruleId] = rule;
    return [this,ruleAction];
};


/**
   Remove rule(s) from the retenet, bottom up, by {@link:module.ReteDataStructures.ActionNode}
   @param {module:ReteDataStructures.ActionNode | Array} rule The rule(s) to remove from the net
   @method
 */
ReteNet.prototype.removeRule = function(rule){
    "use strict";
    this.fireListener("removeRule",rule);
    if(rule instanceof Array){
        rule.forEach(d=>this.removeRule(d));
        return;
    }
    //delete from bottom up
    var action = rule instanceof RDS.ActionNode ? rule : this.actions[rule.id],
        invalidatedActions = ReteActivationsAndDeletion.deleteNodeAndAnyUnusedAncestors(action);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);

    //delete from the allrules record
    if(this.allRules[action.ruleId] !== undefined){
        delete this.allRules[action.ruleId];
    }

    //Remove all nodes scheduled for cleanup
    _.keys(this.allReteNodes).forEach(function(d){
        if(this.allReteNodes[d].cleanup === true){
            let currNode = this.allReteNodes[d];
            delete this.allReteNodesByType[currNode.type][currNode.id];
            delete this.allReteNodes[d];
        }
    },this);
    
    if(this.actions[rule.id] !== undefined){
        delete this.actions[rule.id];
    }
};



/**
   register a join action proposal and performance function   
   @param {{name : string, propose : function, perform : function}} actionObj
   @method
   @see module:ReteActions
*/
ReteNet.prototype.registerAction = function(actionObj){
    console.log("Registering Rete Action:",actionObj);
    if(actionObj.name === undefined || actionObj.perform === undefined || actionObj.propose === undefined){
        throw new Error("Action Registration Failure");
    }
    if(this.actionFunctions[actionObj.name] !== undefined){
        throw new Error("Registration Attempt for existing Action");
    }
    this.actionFunctions[actionObj.name] = actionObj;
};


/**
   Store a node in the appropriate members of the ReteNet
   @param {module:ReteDataStructures.ReteNode} node
   @method
   @private
 */
ReteNet.prototype.storeNode = function(node){
    this.allReteNodes[node.id] = node;

    if(this.allReteNodesByType[node.type] === undefined){
        this.allReteNodesByType[node.type] = {};
    }
    this.allReteNodesByType[node.type][node.id] = node;
};

/**
   Converts rules to an object of their components for easy addition 
   @param {module:RuleCtors.Rule | Array} rules
   @method
   @return {Object}
 */
ReteNet.prototype.convertRulesToComponents = function(rules){
    if(!(rules instanceof Array)){
        rules = [rules];
    }
    var actions = _.flatten(rules.map(d=>_.values(d.actions))),
        conditions = _.flatten(rules.map(d=>_.values(d.conditions))),
        all = actions.concat(conditions).concat(rules),
        components = all.reduce(function(m,v){
            m[v.id] = v;
            return m;
        },{});
    return components;
};

/**
   Clean up
 */
ReteNet.prototype.cleanup = function(){
    //retract all wmes
    _.values(this.allWoMEs).forEach(d=>this.retractWME(d));
    this.allWMEs = {};
    //remove all rules
    this.removeRule(_.values(this.allRules));
};

module.exports = ReteNet;

});

define('underscore',function() { return _; }); return require('ReteClassInterface'); }));